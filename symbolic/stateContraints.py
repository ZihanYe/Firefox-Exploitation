import angr
import logging
log = logging.getLogger("symbolic")

class StateContraints(angr.SimStatePlugin):
    def __init__(self, history= [],
                symbolic_pointer=[],
                unresolved_symbolic_pointer = [], obj_mem=[],
                depth_limited_var= [], sym_call_ret_values=[],
                had_write_primitive = False,
                had_control_hijack = False,
                progress = {}, latest_milestone = None,
                inside_dfs_explore= False):
        super(StateContraints, self).__init__()
        self.history = history
        self.symbolic_pointer = symbolic_pointer # pointers we can control
        self.symbolic_pointer_var = []
        self.unresolved_symbolic_pointer = unresolved_symbolic_pointer
        # primitive
        self.primitive = None
        self.had_write_primitive = had_write_primitive
        self.had_control_hijack = had_control_hijack
        # region of memory that are controlled object
        self.obj_mem = obj_mem
        self.depth_limited_var = depth_limited_var
        self.sym_call_ret_values = sym_call_ret_values
        # progress
        self.progress = progress
        self.latest_milestone = latest_milestone

        self.inside_dfs_explore = inside_dfs_explore

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        return StateContraints(self.history.copy(),
                                self.symbolic_pointer.copy(),
                                self.unresolved_symbolic_pointer.copy(),
                                self.obj_mem.copy(),
                                depth_limited_var = self.depth_limited_var.copy(),
                                sym_call_ret_values=self.sym_call_ret_values.copy(),
                                had_write_primitive = self.had_write_primitive,
                                had_control_hijack = self.had_control_hijack,
                                progress= self.progress, latest_milestone = self.latest_milestone,
                                inside_dfs_explore= self.inside_dfs_explore)


    def merge(self, others, merge_conditions, common_ancestor=None):
        log.warning("Merge has not been implemented for record")
        return False

    def widen(self, others): # pylint: disable=unused-argument
        l.warning("Widening is not implemented for record")
        return False

    def append_history(self, history):
        self.history.append(history)

    def add_obj_mem(self, new_obj):
        # (a, b) = new_obj
        self.obj_mem.append(new_obj)
        # self.obj_mem.append((self.state.solver.BVV(a, size=64), self.state.solver.BVV(b, size=64)))

    def add_symbolic_pointer(self, s, points_to, var):
        self.symbolic_pointer_var.append(var)
        try:
            if not isinstance(s, int):
                self.unresolved_symbolic_pointer.append((s, points_to))
                return
            if not isinstance(points_to, int):
                points_to = None
            if (s, points_to) not in self.symbolic_pointer:
                self.symbolic_pointer.append((s,points_to))
        except Exception as e:
            log.error("[-] WARNING Exception in add_symbolic_pointer")
            print(str(e))
            import IPython; IPython.embed()

    def check_inside_obj(self, addr):
        try:
            #if not isinstance(addr, int) and addr.size() != 64:
            #    return False
            for (a,b) in self.obj_mem:
                sa = self.state.solver.BVV(a, size=64)
                sb = self.state.solver.BVV(b, size=64)
                # if self.state.solver.eval(a <= addr) and self.state.solver.eval(b > addr):
                if self.state.solver.eval(sa <= addr) and self.state.solver.eval(sb > addr):
                    return True
        except Exception as e:
            log.error("[-] EXCEPTION during checking "+ str(addr)+ " is inside a controlled object or not")
            print(str(e))
            import IPython; IPython.embed()
        return False

    def check_inside_obj_index(self, addr):
        try:
            #if not isinstance(addr, int) and addr.size() != 64:
            #    return None
            for i in range(len(self.obj_mem)):
                (a,b) = self.obj_mem[i]
                if self.state.solver.eval(self.state.solver.BVV(a, size=64) <= addr) and self.state.solver.eval(self.state.solver.BVV(b, size=64) > addr):
                    return i
        except Exception as e:
            log.error( "[-] EXCEPTION during checking "+ str(addr)+ " is inside a controlled object or not")
            print(str(e))
            import IPython; IPython.embed()
        return None

    def get_addr_for_var(self, var):
        addr = None
        addrs = list(self.state.memory.addrs_for_hash(hash(var)))
        if len(addrs) > 0:
            addr = min(addrs)
        else:
            # fall into guessing from name
            tmp = str(var).find("mem")
            if tmp != -1:
                components = (str(var)[tmp:]).split('_')
                addr = int('0x' + components[1], 16)
            else:
                tmp = str(var).find("uaf_obj")
                if tmp != -1:
                    index = int(str(var)[tmp+7:].split('_')[0])
                    addr = self.obj_mem[0][0]+index
        return addr

    def get_return_index(self):
        return len(self.sym_call_ret_values)

    def do_symbolic_call(self, ret_symbol):
        self.sym_call_ret_values.append(ret_symbol)

    def add_depth_limited(self, instr, var):
        self.depth_limited_var.append((self.state.history.depth, instr, var))

from angr.sim_state import SimState
SimState.register_default('record', StateContraints)
