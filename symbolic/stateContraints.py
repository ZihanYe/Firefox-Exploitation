import angr

class StateContraints(angr.SimStatePlugin):
    def __init__(self, history= [], symbolic_pointer=[],tainted_mem=[]):
        super(StateContraints, self).__init__()
        self.history = history
        self.symbolic_pointer = symbolic_pointer # pointers we can control
        self.tainted_mem = tainted_mem # we can control the value in tainted mem
        self.is_write_primitive = False
        self.is_control_hijack = False

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        return StateContraints(self.history.copy(), self.symbolic_pointer.copy(), self.tainted_mem.copy())

    def append_history(self, history):
        self.history.append(history)

    def add_symbolic_pointer(self, s):
        if len(self.symbolic_pointer) > 100:
            # dedup
            newlist = []
            for sp in self.symbolic_pointer:
                dup = list(filter(lambda x : x is sp, newlist))
                if len(dup) == 0:
                    newlist.append(sp)
            self.symbolic_pointer = newlist
        self.symbolic_pointer.append(s)

    def add_tainted_mem(self, addr, size): # taint memory starting from addr of size
        # addr is a BV, size can be an int or BV
        if isinstance(size, int):
            size = self.state.solver.BVV(size, 64)
        if isinstance(addr, int):
            addr = self.state.solver.BVV(addr, 64)
        if addr.symbolic or size.symbolic:
            print("[-] WARNING: trying to taint a region with symbolic address or with a symbolic size")
            import IPython; IPython.embed()
            return
        newlist = []
        merged = False
        for (a,b) in self.tainted_mem:
            if merged:
                newlist.append((a,b))
                continue
            if (b <= addr).is_true() or (addr + size <= a).is_true():
                newlist.append((a,b))
            else:
                newstart = addr
                if (a < addr).is_true():
                    newstart = a
                newend = addr+size
                if (b > newend).is_true():
                    newend = b
                newlist.append((newstart, newend))
                merged = True
        if not merged:
            newlist.append((addr, addr+size))

        self.tainted_mem = newlist

    def check_tained(self, addr):
        if not isinstance(addr, int) and addr.symbolic:
            return False
        for (a,b) in self.tainted_mem:
            if (a <= addr).is_true() and (b > addr).is_true():
                return True
        return False
