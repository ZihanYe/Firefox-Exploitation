import angr
from colorama import Fore, Back, Style

# Print const
WARNING = Fore.RED + Style.BRIGHT

class StateContraints(angr.SimStatePlugin):
    def __init__(self, history= [],
                symbolic_pointer=[],
                unresolved_symbolic_pointer = [],
                tainted_mem=[],obj_mem=[],
                dummy_memory_start=0xfffffffff000000,
                sym_call_ret_values=[],
                had_write_primitive = False,
                had_control_hijack = False):
        super(StateContraints, self).__init__()
        self.history = history
        self.symbolic_pointer = symbolic_pointer # pointers we can control
        # memory we have written controlled value to
        self.unresolved_symbolic_pointer = unresolved_symbolic_pointer
        self.tainted_mem = tainted_mem
        # primitive
        self.primitive = None
        self.had_write_primitive = had_write_primitive
        self.had_control_hijack = had_control_hijack
        # region of memory that are controlled object
        self.obj_mem = obj_mem
        self.unused_pointer = dummy_memory_start
        self.sym_call_ret_values = sym_call_ret_values

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        return StateContraints(self.history.copy(),
                                self.symbolic_pointer.copy(),
                                self.unresolved_symbolic_pointer.copy(),
                                self.tainted_mem.copy(),
                                self.obj_mem.copy(),
                                self.unused_pointer,
                                sym_call_ret_values=self.sym_call_ret_values.copy(),
                                had_write_primitive = self.had_write_primitive,
                                had_control_hijack = self.had_control_hijack)

    def append_history(self, history):
        self.history.append(history)

    def add_obj_mem(self, new_obj):
        self.obj_mem.append(new_obj)

    def add_symbolic_pointer(self, s, points_to):
        try:
            if not isinstance(s, int):
                self.unresolved_symbolic_pointer.append((s, points_to))
                return
            if not isinstance(points_to, int):
                points_to = None
            if (s, points_to) not in self.symbolic_pointer:
                self.symbolic_pointer.append((s,points_to))
        except:
            print("exception in add_symbolic_pointer")
            import IPython; IPython.embed()

    def add_tainted_mem(self, addr, size): # taint memory starting from addr of size
        # addr is a BV, size can be an int or BV
        if not isinstance(size, int):
            size = self.state.solver.eval(size)
        if not isinstance(addr, int):
            addr = self.state.solver.eval(addr)

        if not isinstance(addr, int) or not isinstance(size, int):
            print(WARNING + "[-] WARNING: trying to taint a region with symbolic address or with a symbolic size" + Style.RESET_ALL)
            import IPython; IPython.embed()
            return

        newlist = []
        merged = False
        for (a,b) in self.tainted_mem:
            if merged:
                newlist.append((a,b))
                continue
            if (b <= addr) or (addr + size <= a):
                newlist.append((a,b))
            else:
                newstart = addr
                if (a < addr):
                    newstart = a
                newend = addr+size
                if (b > newend):
                    newend = b
                newlist.append((newstart, newend))
                merged = True
        if not merged:
            newlist.append((addr, addr+size))
        self.tainted_mem = newlist

    def check_tained(self, addr):
        try:
            for (a,b) in self.tainted_mem:
                if self.state.solver.eval(a <= addr) and self.state.solver.eval(b > addr):
                    return True
        except:
            print(WARNING + "EXCEPTION during checking ", addr, " is tainted" + Style.RESET_ALL)
        return False

    def check_inside_obj(self, addr):
        try:
            for (a,b) in self.obj_mem:
                if self.state.solver.eval(a <= addr) and self.state.solver.eval(b > addr):
                    return True
        except:
            print(WARNING + "EXCEPTION during checking ", addr, " is inside a controlled object or not" + Style.RESET_ALL)
        return False

    def check_inside_obj_index(self, addr):
        try:
            for i in range(len(self.obj_mem)):
                (a,b) = self.obj_mem[i]
                if self.state.solver.eval(a <= addr) and self.state.solver.eval(b > addr):
                    return i
        except:
            print(WARNING + "EXCEPTION during checking ", addr, " is inside a controlled object or not" + Style.RESET_ALL)
        return None

    def get_return_index(self):
        return len(self.sym_call_ret_values)

    def do_symbolic_call(self, ret_symbol):
        self.sym_call_ret_values.append(ret_symbol)
