import angr

class StateContraints(angr.SimStatePlugin):
    def __init__(self, history= [],
                symbolic_pointer=[],
                tainted_mem=[],obj_mem=[],
                dummy_memory_start=0xfffffffff000000,
                sym_call_count=0,
                sym_call_ret_values=[]):
        super(StateContraints, self).__init__()
        self.history = history
        self.symbolic_pointer = symbolic_pointer # pointers we can control
        # memory we have written to
        self.tainted_mem = tainted_mem
        self.is_write_primitive = False
        self.is_control_hijack = False
        # region of memory that are controlled object
        self.obj_mem = obj_mem
        self.unused_pointer = dummy_memory_start
        self.sym_call_count = sym_call_count
        self.sym_call_ret_values = sym_call_ret_values

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        return StateContraints(self.history.copy(),
                                self.symbolic_pointer.copy(),
                                self.tainted_mem.copy(),
                                self.obj_mem.copy(),
                                self.unused_pointer,
                                sym_call_count=self.sym_call_count,
                                sym_call_ret_values=self.sym_call_ret_values.copy())

    def append_history(self, history):
        self.history.append(history)

    def add_obj_mem(self, new_obj):
        self.obj_mem.append(new_obj)

    def add_symbolic_pointer(self, s, points_to):
        assert isinstance(s, int)
        if not isinstance(points_to, int):
            points_to = None
        if (s, points_to) not in self.symbolic_pointer:
            self.symbolic_pointer.append((s,points_to))

    def add_tainted_mem(self, addr, size): # taint memory starting from addr of size
        # addr is a BV, size can be an int or BV
        if not isinstance(size, int):
            size = self.state.solver.eval(size)
        if not isinstance(addr, int):
            addr = self.state.solver.eval(addr)

        if not isinstance(addr, int) or not isinstance(size, int):
            print("[-] WARNING: trying to taint a region with symbolic address or with a symbolic size")
            import IPython; IPython.embed()
            return

        newlist = []
        merged = False
        for (a,b) in self.tainted_mem:
            if merged:
                newlist.append((a,b))
                continue
            if (b <= addr) or (addr + size <= a):
                newlist.append((a,b))
            else:
                newstart = addr
                if (a < addr):
                    newstart = a
                newend = addr+size
                if (b > newend):
                    newend = b
                newlist.append((newstart, newend))
                merged = True
        if not merged:
            newlist.append((addr, addr+size))
        self.tainted_mem = newlist

    def check_tained(self, addr):
        try:
            for (a,b) in self.tainted_mem:
                if self.state.solver.eval(a <= addr) and self.state.solver.eval(b > addr):
                    return True
        except:
            print("EXCEPTION during checking ", addr, " is tainted")
        return False

    def check_inside_obj(self, addr):
        try:
            for (a,b) in self.obj_mem:
                if self.state.solver.eval(a <= addr) and self.state.solver.eval(b > addr):
                    return True
        except:
            print("EXCEPTION during checking ", addr, " is inside a controlled object or not")
        return False

    def get_return_symbol(self):
        return "sym_call_" + str(self.sym_call_count)

    def do_symbolic_call(self, ret_symbol):
        self.sym_call_ret_values.append(ret_symbol)
        self.sym_call_count += 1
