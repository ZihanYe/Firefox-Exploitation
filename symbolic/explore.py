import angr
import time
import traceback
# import colorama

class Explore:
    def explore(self, s):
        proj = self.ap
        # get a simgr
        self.simgr = proj.factory.simgr(s)

        def priority_key(state):
            calldepth = len(list(state.CalLStack))
            obj_num = len(state.record.obj_mem)
            contraints_complexity = len(state.solver.constraints)
            # put priority to state that is least constrainted
            return contraints_complexity

        spiller = angr.exploration_techniques.Spiller(max=50, priority_key=priority_key)
        self.simgr.use_technique(spiller)
        self.foundSoFar = 0

        stop = False
        self.step = 0
        while not stop:
            print('[+] Stepping: ', self.step)
            # self.debug_simgr(self.simgr)
            try:
                self.simgr.step(step_func = self.step_func)
            except:
                print('simgr error')
                traceback.print_exc()
                if self.debug:
                    import IPython; IPython.embed()
                return

            # import IPython; IPython.embed()
            if len(self.simgr.found) > self.foundSoFar:
                print('[+] Some states reached the end')

            if len(self.simgr.active) == 0:
                print('[+] No active states left, stopping..')
                stop = True

            self.step += 1
            if self.should_stop(self.step):
                print("[+] Reached some stopping condition")
                stop = True

            if self.step % self.log_interval == 0:
                self.dump_executor_into_file(self.log_file)
        import IPython; IPython.embed()


    def step_func(self,lsm):
        lsm.stash(filter_func=lambda state: state.addr == self.context_end, from_stash='active', to_stash='found')
        if not self.continue_with_write_primitive:
            lsm.stash(filter_func=lambda state: state.record.had_write_primitive, from_stash='active', to_stash='primitive')
        if not self.continue_with_control_hijack:
            lsm.stash(filter_func=lambda state: state.record.had_control_hijack, from_stash='active', to_stash='primitive')

    def should_stop(self, step):
        if self.step_limit is not None and step >= self.step_limit:
            return True
        if self.stop_when_write_primtive_found and len(self.write_primitive) >0:
            return True
        if self.stop_when_control_hijack_found and len(self.control_hijack)>0:
            return True
        if self.stop_when_primtive_found is not None and len(self.control_hijack) + len(self.write_primitive) >= self.stop_when_primtive_found:
            return True
        if self.stop_when_active_more_than is not None and len(self.simgr.active) >= self.stop_when_active_more_than:
            return True
        return False
