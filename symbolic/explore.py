import angr
import time
import traceback
import logging
import time
import depthExplorer

log = logging.getLogger("symbolic")

class Explore:
    def explore(self, s):
        proj = self.ap
        # get a simgr
        self.simgr = proj.factory.simgr(s)

        def priority_key(state):
            # calldepth = len(list(state.callstack))
            obj_num = len(state.record.obj_mem)
            contraints_complexity = len(state.solver.constraints)
            # put priority to state that is least constrainted
            return obj_num + contraints_complexity

        def select_states(states, split_num):
            map = {}
            for s in states:
                if s.addr in map:
                    map[s.addr].append(s)
                else:
                    map[s.addr] = [s]

            hi_prior = []
            low_prior = []
            per = split_num // len(map)
            for addr in map:
                ps = map[addr]
                ps.sort(key=priority_key)
                hi_prior += ps[:per]
                low_prior += ps[per:]
            if len(hi_prior) < split_num:
                more = split_num - len(hi_prior)
                hi_prior += low_prior[:more]
                low_prior = low_prior[more:]
            return hi_prior, low_prior

        spiller = angr.exploration_techniques.SimpleSpiller(min=10, max=100, select_states=select_states, priority_key=priority_key)
        self.simgr.use_technique(spiller)
        memwatcher = angr.exploration_techniques.MemoryWatcher(min_memory=None)
        self.simgr.use_technique(memwatcher)

        stop = False
        self.step = 0
        self.avoided = 0
        self.found = 0
        debug_halt_threshold = 200
        error_halt_threshold = 100
        step_info = []
        start_time = time.time()
        while not stop:
            log.info('[+] Stepping: '+ str(self.step))
            # self.debug_simgr(self.simgr)
            try:
                self.simgr.step(step_func = self.step_func)
            except:
                log.error('[-] Simgr error')
                traceback.print_exc()
                if self.debug:
                    import IPython; IPython.embed()
                return

            if self.depth_limit is not None:
                new_wp = []
                new_ch = []
                for w in self.write_primitive:
                    if len(w.record.depth_limited_var) > 0:
                        log.info("[+] exploring in depth a write primitive")
                        ds = depthExplorer.DepthExplorer(self.ap, self.initial_state, w, self.depth_limit, self.uaf_object_base, self.uaf_object_size, self.context_end)
                        cs, ws = ds.depth_explore()
                        new_wp.extend(ws)
                        new_ch.extend(cs)
                    else:
                        new_wp.append(w)
                for c in self.control_hijack:
                    if len(c.record.depth_limited_var) > 0:
                        log.info("[+] exploring in depth a control hijack")
                        ds = depthExplorer.DepthExplorer(self.ap, self.initial_state, c, self.depth_limit, self.uaf_object_base, self.uaf_object_size, self.context_end)
                        cs, ws = ds.depth_explore()
                        new_wp.extend(ws)
                        new_ch.extend(cs)
                    else:
                        new_ch.append(c)
                self.write_primitive = new_wp
                self.control_hijack = new_ch

            if len(self.simgr.active) == 0:
                log.info('[+] No active states left, stopping..')
                stop = True

            self.step += 1
            if self.log_step:
                step_info.append([self.step, len(self.simgr.active), len(self.write_primitive), len(self.control_hijack), (time.time() - start_time)])

            if self.should_stop(self.step):
                log.info("[+] Reached some stopping condition")
                stop = True

            if len(self.simgr.errored) > error_halt_threshold:
                log.warning("[-] WARNING: Too many errors occured, halt:")
                import IPython; IPython.embed()
                error_halt_threshold = error_halt_threshold *2

            if self.debug and len(self.simgr.active) > debug_halt_threshold:
                log.warning("[+] Stop for debugging")
                import IPython; IPython.embed()
                debug_halt_threshold = debug_halt_threshold*2

            if self.step % self.log_interval == 0:
                self.dump_executor_into_file(self.log_file+'.log')
                self.dump_step_info(self.log_file+'_step.log', step_info)

            if self.step % 200 == 0:
                self.trim_state_history()

        import IPython; IPython.embed()
        self.dump_executor_into_file(self.log_file+'final.log')


    def step_func(self,lsm):
        lsm.stash(filter_func=lambda state: state.addr == self.context_end, from_stash='active', to_stash='found')
        lsm.stash(filter_func=lambda state: state.addr in self.avoids, from_stash='active', to_stash='avoided')
        if not self.continue_with_write_primitive:
            lsm.stash(filter_func=lambda state: state.record.had_write_primitive, from_stash='active', to_stash='primitive')
        if not self.continue_with_control_hijack:
            lsm.stash(filter_func=lambda state: state.record.had_control_hijack, from_stash='active', to_stash='primitive')
        self.found += len(lsm.found)
        self.avoided += len(lsm.avoided)
        lsm.drop(filter_func=lambda x: True, stash='found')
        lsm.drop(filter_func=lambda x: True, stash='avoided')
        return lsm

    def should_stop(self, step):
        if self.step_limit is not None and step >= self.step_limit:
            return True
        if self.stop_when_write_primtive_found is not None and len(self.write_primitive) > self.stop_when_write_primtive_found:
            return True
        if self.stop_when_control_hijack_found is not None and len(self.control_hijack) > self.stop_when_control_hijack_found:
            return True
        if self.stop_when_primtive_found is not None and len(self.control_hijack) + len(self.write_primitive) >= self.stop_when_primtive_found:
            return True
        if self.stop_when_active_more_than is not None and len(self.simgr.active) >= self.stop_when_active_more_than:
            return True
        return False

    def count_milestones(self, lsm):
        if len(self.milestones) == 0:
            return
        # number of states that have passed each milstones
        counts = {}
        # number of states that just reached a milestone
        latest_milestones = {}
        for k in self.milestones:
            counts[hex(k)] = 0
            latest_milestones[hex(k)] = 0

        for s in lsm.active:
            for k in s.record.progress:
                counts[k] += 1
            if s.record.latest_milestone is not None:
                latest_milestones[s.record.latest_milestone] += 1
        return counts, latest_milestones

    def trim_state_history(self):
        for s in self.simgr.active:
            s.history.trim()

    def dump_step_info(self, file, steps):
        with open(file, 'w') as f:
            for s in steps:
                for i in s:
                    f.write("%s " % i)
                f.write("\n")
