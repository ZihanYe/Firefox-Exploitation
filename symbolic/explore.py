import angr
import time
import traceback
# import colorama

class Explore:
    def explore(self, s):
        proj = self.ap
        # get a simgr
        self.simgr = proj.factory.simgr(s)
        self.foundSoFar = 0

        stop = False
        step = 0
        while not stop:
            print('[+] Stepping: ', step)
            # self.debug_simgr(self.simgr)
            try:
                self.simgr.step(step_func = self.step_func)
            except:
                print('simgr error')
                traceback.print_exc()
                import IPython; IPython.embed()
                return

            # import IPython; IPython.embed()
            if len(self.simgr.found) > self.foundSoFar:
                print('[+] Some states reached the end')
                self.foundSoFar = len(self.simgr.found)

            if len(self.simgr.active) == 0:
                print('[+] No active states left, stopping..')
                stop = True

            step += 1
            if self.should_stop(step):
                print("[+] Reached som stopping condition")
                stop = True

            if step % 50 == 0:
                print("step: ", step)
                # import IPython; IPython.embed()
        import IPython; IPython.embed()


    def step_func(self,lsm):
        lsm.stash(filter_func=lambda state: state.addr == self.context_end, from_stash='active', to_stash='found')
        if not self.continue_with_write_primitive:
            lsm.stash(filter_func=lambda state: state.record.had_write_primitive, from_stash='active', to_stash='primitive')
        if not self.continue_with_control_hijack:
            lsm.stash(filter_func=lambda state: state.record.had_control_hijack, from_stash='active', to_stash='primitive')

    def should_stop(self, step):
        if self.step_limit is not None and step >= self.step_limit:
            return True

        if self.stop_when_write_primtive_found and len(self.write_primitive) >0:
            return True

        if self.stop_when_control_hijack_found and len(self.control_hijack)>0:
            return True

        if self.stop_when_primtive_found is not None and len(self.control_hijack) + len(self.write_primitive) >= self.stop_when_primtive_found:
            return True

        if self.stop_when_active_more_than is not None and len(self.simgr.active) >= self.stop_when_active_more_than:
            return True

        return False
