import angr
import time
import traceback
import logging
log = logging.getLogger("symbolic")

class Explore:
    def explore(self, s):
        proj = self.ap
        # get a simgr
        self.simgr = proj.factory.simgr(s)

        def priority_key(state):
            calldepth = len(list(state.callStack))
            obj_num = len(state.record.obj_mem)
            contraints_complexity = len(state.solver.constraints)
            # put priority to state that is least constrainted
            return contraints_complexity

        # spiller = angr.exploration_techniques.Spiller(max=50, priority_key=priority_key)
        # self.simgr.use_technique(spiller)
        memwatcher = angr.exploration_techniques.MemoryWatcher(min_memory=None)
        self.simgr.use_technique(memwatcher)

        stop = False
        self.step = 0
        error_halt_threshold = 100
        while not stop:
            log.info('[+] Stepping: '+ str(self.step))
            # self.debug_simgr(self.simgr)
            try:
                self.simgr.step(step_func = self.step_func)
            except:
                log.error('[-] Simgr error')
                traceback.print_exc()
                if self.debug:
                    import IPython; IPython.embed()
                return

            if len(self.simgr.active) == 0:
                log.info('[+] No active states left, stopping..')
                stop = True

            self.step += 1
            if self.should_stop(self.step):
                log.info("[+] Reached some stopping condition")
                stop = True

            if len(self.simgr.errored) > error_halt_threshold:
                log.warning("[-] WARNING: Too many errors occured, halt:")
                import IPython; IPython.embed()
                error_halt_threshold = error_halt_threshold *2

            if self.step % self.log_interval == 0:
                self.dump_executor_into_file(self.log_file+'.log')
        self.dump_executor_into_file(self.log_file+'final.log')
        import IPython; IPython.embed()


    def step_func(self,lsm):
        lsm.stash(filter_func=lambda state: state.addr == self.context_end, from_stash='active', to_stash='found')
        lsm.stash(filter_func=lambda state: state.addr in self.avoids, from_stash='active', to_stash='avoided')
        if not self.continue_with_write_primitive:
            lsm.stash(filter_func=lambda state: state.record.had_write_primitive, from_stash='active', to_stash='primitive')
        if not self.continue_with_control_hijack:
            lsm.stash(filter_func=lambda state: state.record.had_control_hijack, from_stash='active', to_stash='primitive')
        return lsm

    def should_stop(self, step):
        if self.step_limit is not None and step >= self.step_limit:
            return True
        if self.stop_when_write_primtive_found is not None and len(self.write_primitive) > self.stop_when_write_primtive_found:
            return True
        if self.stop_when_control_hijack_found is not None and len(self.control_hijack) > self.stop_when_control_hijack_found:
            return True
        if self.stop_when_primtive_found is not None and len(self.control_hijack) + len(self.write_primitive) >= self.stop_when_primtive_found:
            return True
        if self.stop_when_active_more_than is not None and len(self.simgr.active) >= self.stop_when_active_more_than:
            return True
        return False

    def prepare_pickle_state(self, state):
        # gdbm only accept dicts with string/byte string element/indicies
        # do the conversion
        # temp
        pass
