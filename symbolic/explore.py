import angr
import time
import traceback
import logging
import time
import depthExplorer
from lazySolver import lazySolver

log = logging.getLogger("symbolic")

class Explore:
    def explore(self, s):
        proj = self.ap
        # get a simgr
        self.simgr = proj.factory.simgr(s)

        def priority_key(state):
            # calldepth = len(list(state.callstack))
            obj_num = len(state.record.obj_mem)
            contraints_complexity = len(state.solver.constraints)
            # put priority to state that is least constrainted
            return obj_num + contraints_complexity

        def select_states(states, split_num):
            map = {}
            for s in states:
                if s.addr in map:
                    map[s.addr].append(s)
                else:
                    map[s.addr] = [s]

            hi_prior = []
            low_prior = []
            per = split_num // len(map)
            for addr in map:
                ps = map[addr]
                ps.sort(key=priority_key)
                hi_prior += ps[:per]
                low_prior += ps[per:]
            if len(hi_prior) < split_num:
                more = split_num - len(hi_prior)
                hi_prior += low_prior[:more]
                low_prior = low_prior[more:]
            return hi_prior, low_prior

        spiller = angr.exploration_techniques.SimpleSpiller(min=10, max=100, select_states=select_states, priority_key=priority_key)
        self.simgr.use_technique(spiller)
        memwatcher = angr.exploration_techniques.MemoryWatcher(min_memory=None)
        self.simgr.use_technique(memwatcher)

        stop = False
        self.step = 0
        self.avoided = 0
        self.found = 0
        debug_halt_threshold = 200
        error_halt_threshold = 100
        step_info = []
        start_time = time.time()
        while not stop:
            log.info('[+] Stepping: '+ str(self.step))
            # self.debug_simgr(self.simgr)
            try:
                self.simgr.step(step_func = self.step_func)
            except:
                log.error('[-] Simgr error')
                traceback.print_exc()
                if self.debug:
                    import IPython; IPython.embed()
                return

            if len(self.simgr.active) == 0:
                log.info('[+] No active states left, stopping..')
                stop = True

            self.step += 1
            if self.log_step:
                step_info.append([self.step, len(self.simgr.active), len(self.write_primitive), len(self.control_hijack), (time.time() - start_time)])

            if self.should_stop(self.step):
                log.info("[+] Reached some stopping condition")
                stop = True

            if len(self.simgr.errored) > error_halt_threshold:
                log.warning("[-] WARNING: Too many errors occured, halt:")
                import IPython; IPython.embed()
                error_halt_threshold = error_halt_threshold *2

            if self.debug and len(self.simgr.active) > debug_halt_threshold:
                log.warning("[+] Stop for debugging")
                import IPython; IPython.embed()
                debug_halt_threshold = debug_halt_threshold*2

            if self.debug_step is not None and self.step in self.debug_step:
                log.warning("[+] halt for debugging")
                import IPython; IPython.embed()

            if self.step % self.log_interval == 0:
                self.dump_executor_into_file(self.log_file+'.log')
                self.dump_step_info(self.log_file+'_step.log', step_info)

            if self.step % 200 == 0:
                self.trim_state_history()

        import IPython; IPython.embed()
        self.dump_executor_into_file(self.log_file+'final.log')


    def step_func(self,lsm):
        lsm.stash(filter_func=lambda state: state.addr == self.context_end, from_stash='active', to_stash='found')
        lsm.stash(filter_func=lambda state: state.addr in self.avoids, from_stash='active', to_stash='avoided')
        if not self.continue_with_write_primitive:
            lsm.stash(filter_func=lambda state: state.record.had_write_primitive, from_stash='active', to_stash='primitive')
        if not self.continue_with_control_hijack:
            lsm.stash(filter_func=lambda state: state.record.had_control_hijack, from_stash='active', to_stash='primitive')
        self.found += len(lsm.found)
        self.avoided += len(lsm.avoided)
        lsm.drop(filter_func=lambda x: True, stash='found')
        lsm.drop(filter_func=lambda x: True, stash='avoided')

        for e in lsm.errored:
            success = False
            state = e.state
            try:
                msg = str(e.error)
                if msg.startswith('No bytes'):
                    index = msg.find('0x')
                    if index != -1:
                        addr = msg[index: -1]
                        success = self.debugger.resolve_address(state, int(addr, 16))
            except Exception as e:
                success = False
                print(str(e))
            if success:
                lsm.stashes['active'].append(state)

        return lsm

    def should_stop(self, step):
        if self.step_limit is not None and step >= self.step_limit:
            return True
        if self.stop_when_write_primtive_found is not None and len(self.write_primitive) > self.stop_when_write_primtive_found:
            return True
        if self.stop_when_control_hijack_found is not None and len(self.control_hijack) > self.stop_when_control_hijack_found:
            return True
        if self.stop_when_primtive_found is not None and len(self.control_hijack) + len(self.write_primitive) >= self.stop_when_primtive_found:
            return True
        if self.stop_when_active_more_than is not None and len(self.simgr.active) >= self.stop_when_active_more_than:
            return True
        return False

    def count_milestones(self, lsm):
        if len(self.milestones) == 0:
            return
        # number of states that have passed each milstones
        counts = {}
        # number of states that just reached a milestone
        latest_milestones = {}
        for k in self.milestones:
            counts[hex(k)] = 0
            latest_milestones[hex(k)] = 0

        for s in lsm.active:
            for k in s.record.progress:
                counts[k] += 1
            if s.record.latest_milestone is not None:
                latest_milestones[s.record.latest_milestone] += 1
        return counts, latest_milestones

    def trim_state_history(self):
        for s in self.simgr.active:
            s.history.trim()

    def dump_step_info(self, file, steps):
        with open(file, 'w') as f:
            for s in steps:
                for i in s:
                    f.write("%s " % i)
                f.write("\n")
