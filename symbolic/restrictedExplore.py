import angr
import logging
import dfsSimgr
log = logging.getLogger("symbolic")

class RestrictedExplore:
    # before a sucessor is to be added
    def track_successor(self, state):
        if not state.solver.satisfiable(extra_constraints=self.plain_constraints):
            state.inspect.exit_jumpkind =  'Ijk_SigFPE_IntDiv'
            print("get rid of a path")
            import IPython; IPython.embed()

    # after a call: call stack pushed
    def track_call(self, state):
        call_from = state.scratch.exit_ins_addr
        depth = 0
        for c in state.callstack:
            depth += 1
        if depth == self.depth_limit+1:
            (instr, var) = state.record.depth_limited_var[0]
            if instr == call_from:
                # part of path replaced by replaced_var before
                # now find a path that sat replaced_var (dfs)
                print("reach a depth limited point")
                import IPython; IPython.embed;
                state.record.depth_limited_var = state.record.depth_limited_var[1:]
                # spawn a simgr
                sub_simgr = dfsSimgr.DfsSimgr(state, var)
                after_ret = sub_simgr.explore()
                if after_ret is not None:
                    state.history.jumpkind = 'Ijk_SigFPE_IntDiv'
                    # state.global.forking_states = [after_ret]

    # after a return
    def track_ret(self, state):
        call_from = state.callstack.top.func_addr
        depth = 0
        for c in state.callstack:
            depth += 1
        if depth == self.depth_limit:
            (depth, instr, var) = state.record.depth_limited_var
            if instr == call_from:
                # check current path satisfiable and consistent
                cs = []
                for c in self.depth_constraints:
                    for l in c.leaf_asts():
                        if l is var:
                            cs.append(c)
                cs.append(var == state.regs.rax)
                if state.solver.satisfiable(extra_constraints = cs):
                    state.record.depth_limited_var = state.record.depth_limited_var[1:]
                    self.depth_constraints.append(var == state.regs.rax)
                    self.simgr.stashes['deferred'] = []
                else:
                    # unsat
                    state.history.jumplind =  'Ijk_SigFPE_IntDiv'
