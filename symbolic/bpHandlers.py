import angr
from symCallProc import SymCallProc

class BpHandlers:
    def track_reads(self, state):
        print('=' * 100 + 'MEMREAD')
        print('read from ', state.inspect.mem_read_address, ' of size ', state.inspect.mem_read_length)

        if not isinstance(state.inspect.mem_read_length,int) and state.inspect.mem_read_length.symbolic:
            print('[+] reading with symbolic length')
            import IPython; IPython.embed()

        # self.dump_state(state)
        print('uninit:', state.inspect.mem_read_address.uninitialized,\
            'symbolic:', state.inspect.mem_read_address.symbolic)

        t=state.memory.load(state.inspect.mem_read_address,size=1,inspect=False)
        if (t.uninitialized and not state.inspect.mem_read_address.symbolic):
            print('[+] reading from uninitialized concrete memory address ', state.inspect.mem_read_address)
            self.dump_state(state)
            # import IPython; IPython.embed()
        elif (t.uninitialized and state.inspect.mem_read_address.symbolic):
            print('[+] reading from uninitialized symbolic memory address')
            print('[+] concretizing symbolic memory address and setting symbolic value at the address')
            t=state.memory.load(state.inspect.mem_read_address,size=state.inspect.mem_read_length,inspect=False)
            # import IPython; IPython.embed()

    def track_after_reads(self, state):
        if state.inspect.mem_read_address.symbolic:
            print('[+] reading from symbolic address')
            concrete_addr = state.solver.eval(state.inspect.mem_read_address)
            state.record.add_symbolic_pointer(state.inspect.mem_read_address)
            # dereference of a controlled pointer
            '''
            state.record.append_history({
                'inst': state.addr,
                'access': 'dereference',
                'pointer': state.inspect.mem_read_address,
                'concrete_addr': concrete_addr,
                'read_size': state.inspect.mem_read_length,
                'value': state.inspect.mem_read_expr,
                'constraints': state.solver.constraints.copy(),
            })
            '''
        elif state.record.check_tained(state.inspect.mem_read_address):
            print('[+] reading from tainted concrete address')
            # read from tainted memory (tainted memory is region of memory we've written controlled value to)
            state.record.append_history({
                'inst': state.addr,
                'access': 'read_taint',
                'address': state.inspect.mem_read_address,
                'read_size': state.inspect.mem_read_length,
                'value': state.inspect.mem_read_expr,
                'constraints': state.solver.constraints.copy(),
            })



    def track_writes(self, state):
        print('=' * 100 + 'MEMWRITE')
        print('write ', state.inspect.mem_write_expr, ' to ', state.inspect.mem_write_address \
            , ' of size ', state.inspect.mem_write_length , 'Write target type:', type(state.inspect.mem_write_address))

        if not isinstance(state.inspect.mem_write_length,int) and state.inspect.mem_write_length.symbolic:
            print('[+] writing with symbolic length')
            import IPython; IPython.embed()

        print('uninit:', state.inspect.mem_write_address.uninitialized,\
            'symbolic:', state.inspect.mem_write_address.symbolic)
        if state.inspect.mem_write_address.symbolic:
            state.record.add_symbolic_pointer(state.inspect.mem_read_address)
            if state.inspect.mem_write_expr.symbolic:
                print('[+] writing symbolic value to symbolic address')
                print('Write primitive!')
                s = state.copy()
                self.write_primitive.append(s)
                state.record.is_write_primitive = True
                import IPython; IPython.embed()
                # TODO: we don't need to continue anymore
            else:
                print('[+] writing concrete value to symbolic address')
            import IPython; IPython.embed()
        else: # concrete address
            if state.inspect.mem_write_expr.symbolic:
                print('[+] writing symbolic value to concrete address')
                print('[+] add to taint memory region')
                # import IPython; IPython.embed()

    def track_after_writes(self,state):
        if state.inspect.mem_write_address.symbolic:
            concrete_addr = state.solver.eval(state.inspect.mem_write_address)
            # i think it has been Concretized
            if not concrete_addr.symbolic:
                state.record.add_tainted_mem(concrete_addr, state.inspect.mem_write_length)
            else:
                print("[-] WARNING: something weong during address concretization")
                import IPython; IPython.embed()

            if not state.inspect.mem_write_expr.symbolic:
                state.record.append_history({
                    'inst': state.addr,
                    'access': 'info_leak',
                    'address': state.inspect.mem_write_address,
                    'write_size': state.inspect.mem_write_length,
                    'value': state.inspect.mem_write_expr,
                    'constraints': state.solver.constraints.copy(),
                })
            print("TODO: debug constraints after writes")
            import IPython; IPython.embed()
        else:
            if state.inspect.mem_write_expr.symbolic:
                state.record.add_tainted_mem(state.inspect.mem_write_address, state.inspect.mem_write_length)
                state.record.append_history({
                    'inst': state.addr,
                    'access': 'taint_mem',
                    'address': state.inspect.mem_write_address,
                    'write_size': state.inspect.mem_write_length,
                    'value': state.inspect.mem_write_expr,
                    'constraints': state.solver.constraints.copy(),
                })


    def track_symbolic_variable(self, state):
        print('=' * 100 + 'SYMBOL')
        print(state.inspect.symbolic_name)
        print(state.inspect.symbolic_size)
        print(state.inspect.symbolic_expr)
        pass

    def track_call(self, state):
        print('=' * 100 + 'CALL')
        addr = state.inspect.function_address
        print('call ', addr)
        if addr.symbolic:
            self.control_hijack.append(state.copy())
            print('[+] Call with symbolic address ', addr.symbolic)
            state.record.append_history({
                'inst': state.addr,
                'access': 'call',
                'address': state.inspect.function_address,
                'constraints': state.solver.constraints.copy(),
            })
            state.inspect.function_address = state.solver.BVV(0xfffffffffffff00e, 64)
            state.scratch.target = state.solver.BVV(0xfffffffffffff00e, 64)

    def track_after_address_concretization(self, state):
        print('=' * 100 + 'CONCRETIZATION')
        print(state.inspect.address_concretization_strategy)
        print(state.inspect.address_concretization_action)
        print(state.inspect.address_concretization_memory)
        print(state.inspect.address_concretization_expr)
        print(state.inspect.address_concretization_add_constraints)
        print(state.inspect.address_concretization_result)
        if state.inspect.address_concretization_result is not None and len(state.inspect.address_concretization_result) > 1:
            print("address concretized to multiple results ")
            import IPython; IPython.embed()

        if state.inspect.address_concretization_action == 'store':
            import IPython; IPython.embed()
