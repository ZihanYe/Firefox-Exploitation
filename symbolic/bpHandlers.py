import angr
from colorama import Fore, Back, Style
import logging

log = logging.getLogger("symbolic")

# Print const
WARNING = Fore.RED + Style.BRIGHT

class BpHandlers:
    def track_reads(self, state):
        log.debug('=' * 50 + 'MEMREAD')
        log.debug('read from ' + str(state.inspect.mem_read_address) + ' of size ' + str(state.inspect.mem_read_length))

        if not isinstance(state.inspect.mem_read_length,int) and state.inspect.mem_read_length.symbolic:
            log.critical('[+] reading with symbolic length')
            if self.debug:
                import IPython; IPython.embed()

        log.debug('uninit:'+ str(state.inspect.mem_read_address.uninitialized) + \
            'symbolic:'+ str(state.inspect.mem_read_address.symbolic))

        # t=state.memory.load(state.inspect.mem_read_address,size=1,inspect=False)
        # if (t.uninitialized and not state.inspect.mem_read_address.symbolic):
        #     return
            # log.warning('[-] WARNING: reading from uninitialized concrete memory address '+ str(state.inspect.mem_read_address))
            # size = state.solver.eval(state.inspect.mem_read_length)
            # initialize untinitialized concrete memory with 0 (instead of symbol)
            # state.memory.store(state.inspect.mem_read_address, state.solver.BVV(0, size*self.ap.arch.byte_width),inspect=False)
        # elif (t.uninitialized and state.inspect.mem_read_address.symbolic):
            # log.debug('[+] reading from uninitialized symbolic memory address')
            # log.debug('[+] concretizing symbolic memory address and setting symbolic value at the address')
            # t=state.memory.load(state.inspect.mem_read_address,size=state.inspect.mem_read_length,inspect=False)

    def track_after_reads(self, state):
        if state.inspect.mem_read_address.symbolic:
            try:
                call_id = self.is_symbolic_return(state, state.inspect.mem_read_address)
                if call_id != -1:
                    state.record.append_history({
                        'access': 'deref_ret_val_r',
                        'inst': state.addr,
                        'call_id': call_id,
                        'read_from': state.inspect.mem_read_address,
                        'read_size': state.inspect.mem_read_length,
                        'value': state.inspect.mem_read_expr,
                        'constraints': state.solver.constraints.copy(),
                    })
            except Exception as e:
                log.error("[-] EXCEPTION: in checking use of symbolic return")
                if self.debug:
                    print(str(e))
                    import IPython; IPython.embed()

            # find out where the pointer is
            if not self.is_depth_limit_return(state, state.inspect.mem_read_address):
                self.__add_symbolic_pointer(state, state.inspect.mem_read_address)

        # elif state.record.check_tained(state.inspect.mem_read_address):
            # print('[+] reading from tainted concrete address')
            # read from tainted memory (tainted memory is region of memory we've written controlled value to)
            '''
            state.record.append_history({
                'access': 'read_taint',
                'inst': state.addr,
                'read_from': state.inspect.mem_read_address,
                'read_size': state.inspect.mem_read_length,
                'value': state.inspect.mem_read_expr,
                'constraints': state.solver.constraints.copy(),
            })
            '''

    def track_writes(self, state):
        log.debug('=' * 50 + 'MEMWRITE')
        log.debug('write '+ str(state.inspect.mem_write_expr) + ' to '+ str(state.inspect.mem_write_address)+ \
             ' of size '+ str(state.inspect.mem_write_length)+ 'Write target type:')

        if not isinstance(state.inspect.mem_write_length,int) and state.inspect.mem_write_length.symbolic:
            log.critical('[+] writing with symbolic length')
            if self.debug:
                import IPython; IPython.embed()

        log.debug('uninit:'+ str(state.inspect.mem_write_address.uninitialized) + \
            'symbolic:'+ str(state.inspect.mem_write_address.symbolic))
        if (not isinstance(state.inspect.mem_write_address, int)) and state.inspect.mem_write_address.symbolic:
            if not self.is_depth_limit_return(state, state.inspect.mem_write_address) and state.inspect.mem_write_expr.symbolic:
                # address and value should be unconstrained (at least to a range of values)
                # possible_addrs = state.solver.eval_upto(state.inspect.mem_write_address, 2)
                log.info('[+] writing symbolic value to symbolic address')
                log.info('[+] Write primitive!')
                state.record.had_write_primitive = True
                s = state.copy()
                s.record.primitive = {
                    'type': 'WWW',
                    'inst': state.addr,
                    'write_to': state.inspect.mem_write_address,
                    'write_size': state.inspect.mem_write_length,
                    'value': state.inspect.mem_write_expr,
                    'depth': state.history.depth,
                }
                self.add_write_primitive(s)

    def track_after_writes(self,state):
        written = False
        if (not isinstance(state.inspect.mem_write_expr, int)) and state.inspect.mem_write_expr.symbolic:
            try:
                call_id = self.is_symbolic_return(state, state.inspect.mem_write_expr)
                if call_id != -1:
                    state.record.append_history({
                        'access': 'write_ret_val',
                        'inst': state.addr,
                        'call_id': call_id,
                        'write_to': state.inspect.mem_write_address,
                        'write_size': state.inspect.mem_write_length,
                        'value': state.inspect.mem_write_expr,
                        'constraints': state.solver.constraints.copy(),
                    })
                    written = True
            except Exception as e:
                log.error("[-] EXCEPTION: in checking use of symbolic return")
                if self.debug:
                    print(str(e))
                    import IPython; IPython.embed()
            """
            concrete_addr = state.solver.eval(state.inspect.mem_write_address)
            if isinstance(concrete_addr, int):
                log.debug('[+] add to taint memory region')
                state.record.add_tainted_mem(concrete_addr, state.inspect.mem_write_length)
                if not written:
                    state.record.append_history({
                        'access': 'taint_mem',
                        'inst': state.addr,
                        'write_to': concrete_addr,
                        'write_size': state.inspect.mem_write_length,
                        'value': state.inspect.mem_write_expr,
                        'constraints': state.solver.constraints.copy(),
                    })
                    written = True
            else:
                log.error("[-] something wrong during address concretization")
                if self.debug:
                    import IPython; IPython.embed()
            """

        if (not isinstance(state.inspect.mem_write_address, int)) and state.inspect.mem_write_address.symbolic:
            if not written:
                try:
                    call_id = self.is_symbolic_return(state, state.inspect.mem_write_address)
                    if call_id != -1:
                        state.record.append_history({
                            'access': 'deref_ret_val_w',
                            'inst': state.addr,
                            'call_id': call_id,
                            'write_to': state.inspect.mem_write_address,
                            'write_size': state.inspect.mem_write_length,
                            'value': state.inspect.mem_write_expr,
                            'constraints': state.solver.constraints.copy(),
                        })
                except Exception as e:
                    log.error("[-] EXCEPTION: in checking use of symbolic return")
                    if self.debug:
                        print(str(e))
                        import IPython; IPython.embed()

            if not self.is_depth_limit_return(state, state.inspect.mem_write_address):
                self.__add_symbolic_pointer(state, state.inspect.mem_write_address)


    def track_symbolic_variable(self, state):
        pass

    def track_call(self, state):
        log.debug('=' * 50 + 'CALL')
        addr = state.inspect.function_address
        if addr.symbolic and not self.is_depth_limit_return(state, addr):
            log.info('[+] Call with symbolic address '+ str(addr))
            state.record.had_control_hijack = True
            s = state.copy()
            s.record.primitive = {
                'type': 'CONTROL',
                'call_from': state.scratch.exit_ins_addr,
                'call': state.inspect.function_address,
                'depth': state.history.depth
            }
            self.add_control_hijack(s)
            state.record.append_history({
                'access': 'call',
                'id': state.record.get_return_index(),
                'call_from': state.scratch.exit_ins_addr,
                'call': state.inspect.function_address,
                'constraints': state.solver.constraints.copy(),
                'regs': state.regs.copy(),
            })
            state.inspect.function_address = state.solver.BVV(0xfffffffffffff00e, 64)
            state.scratch.target = state.solver.BVV(0xfffffffffffff00e, 64)
        if self.depth_limit is not None:
            depth = 0
            for c in state.callstack:
                depth += 1
            if depth >= self.depth_limit:
                log.warning('[+] call stack is too deep, stop going deeper.')
                state.inspect.function_address = state.solver.BVV(0xfffffffffffff01e, 64)
                state.scratch.target = state.solver.BVV(0xfffffffffffff01e, 64)

    def track_after_address_concretization(self, state):
        # print('=' * 100 + 'CONCRETIZATION')
        # print(state.inspect.address_concretization_strategy)
        # print(state.inspect.address_concretization_action)
        # print(state.inspect.address_concretization_memory)
        # print(state.inspect.address_concretization_expr)
        # print(state.inspect.address_concretization_add_constraints)
        # print(state.inspect.address_concretization_result)
        # if state.inspect.address_concretization_result is not None and len(state.inspect.address_concretization_result) > 1:
        #     print(WARNING + "[-] WARNING: address concretized to multiple results " + Style.RESET_ALL)
        #     if self.debug:
        #         import IPython; IPython.embed()
        pass

    def track_after_jump(self, state):
        if state.inspect.exit_jumpkind == 'Ijk_Boring':
            log.debug('=' * 50 + 'JUMP')
            target = state.inspect.exit_target
            if not isinstance(target, int) and target.symbolic and not self.is_depth_limit_return(state, target):
                log.info('[+] jump to symbolic address, it is a control hijack!')
                state.record.had_control_hijack = True
                s = state.copy()
                s.record.primitive = {
                    'type': 'JUMP',
                    'jump_from': state.scratch.exit_ins_addr,
                    'jump_to': state.inspect.exit_target,
                    'depth': state.history.depth
                }
                self.add_control_hijack(s)
                state.record.append_history({
                    'access': 'jump',
                    'from': state.scratch.exit_ins_addr,
                    'constraints': state.solver.constraints.copy(),
                    'regs': state.regs.copy(),
                })

    def track_syscall(self, state):
        pass

    def track_symbolic_variable(self, state):
        pass

    def __add_symbolic_pointer(self,state,addr):
        try:
            addrs_of_pointer = self.__get_address_of_symbolic_pointer(state, addr)
            if addrs_of_pointer is not None:
                base_addr = state.memory.load(addrs_of_pointer, size=int(self.ap.arch.bits//self.ap.arch.byte_width), inspect=False, endness=self.ap.arch.memory_endness)
                points_to = state.solver.eval(base_addr)
                state.record.add_symbolic_pointer(addrs_of_pointer, points_to, addr)
            else:
                log.warning("[-] Cannot find the base address of the pointer in any object :" + str(addr))
                points_to = state.solver.eval(addr)
                state.record.add_symbolic_pointer(addr, points_to, addr)
        except Exception as e:
            log.error("[-] EXCEPTION during adding symbolic pointer "+ str(addr))
            if self.debug:
                print(str(e))
                import IPython; IPython.embed()


    def __get_address_of_symbolic_pointer(self, state, addr):
        if addr.op == '__add__':
            # possibly base + offset
            children = list(addr.args)
            for c in children:
                cv = state.solver.eval(c)
                if state.record.check_inside_obj(cv):
                    # mostly likely to be an address
                    return self.__get_address_of_symbolic_pointer(state, c)
            # guess from the Value
            return None
        else:
            # should be the base
            leaf = list(addr.leaf_asts())
            addr_start = None
            for l in leaf:
                if l.symbolic:
                    # ls = list(state.memory.addrs_for_hash(hash(l)))
                    addr = state.record.get_addr_for_var(l)
                    if addr is not None and (addr_start is None or addr_start > addr):
                        addr_start = addr
            if addr_start is not None:
                return addr_start
        return None

    def is_symbolic_return(self, state, expr):
        if isinstance(expr, int) or not expr.symbolic:
            return -1
        leaf = list(expr.leaf_asts())
        for l in leaf:
            index = 0
            for s in state.record.sym_call_ret_values:
                if s is l:
                    log.debug("[+] use of symbolic return value of call "+ str(index)+ " found")
                    return index
                index += 1
        return -1

    def is_depth_limit_return(self,state, expr):
        if isinstance(expr, int) or not expr.symbolic:
            return False
        leaf = list(expr.leaf_asts())
        for l in leaf:
            if "depth_limit" in str(l):
                return True
        return False
