
import logging
import datetime

l = logging.getLogger(name=__name__)
from . import ExplorationTechnique

class SimpleSpiller(ExplorationTechnique):
    """
    Automatically spill states out. It can spill out states to a different stash
    """

    def __init__(
        self,
        src_stash="active", min=10, max=100, #pylint:disable=redefined-builtin
        staging_stash="spill_stage",
        priority_key=None, select_states=None,
    ):
        """
        Initializes the spiller.

        @param max: the number of states that are *not* spilled
        @param src_stash: the stash from which to spill states (default: active)
        @param staging_stash: the stash *to* which to spill states (default: "spill_stage")
        @param staging_max: the number of states that can be in the staging stash before things get spilled to ANA (default: None. If staging_stash is set, then this means unlimited, and ANA will not be used).
        @param priority_key: a function that takes a state and returns its numberical priority (MAX_INT is lowest priority). By default, self.state_priority will be used, which prioritizes by object ID.
        @param select_states
        """
        super(SimpleSpiller, self).__init__()
        self.max = max
        self.min = min
        self.src_stash = src_stash
        self.staging_stash = staging_stash

        self.priority_key = priority_key
        self.select_states = select_states


    def _get_priority(self, state):
        return (self.priority_key or self.state_priority)(state)

    def step(self, simgr, stash='active', **kwargs):
        simgr = simgr.step(stash=stash, **kwargs)

        l.debug("STASH STATUS: active: %d, staging: %d", len(simgr.stashes[self.src_stash]), len(simgr.stashes[self.staging_stash]))

        states = simgr.stashes[self.src_stash]
        staged_states = simgr.stashes.setdefault(self.staging_stash, [ ]) if self.staging_stash else [ ]

        if len(states) < self.min:
            missing = (self.max + self.min) // 2 - len(states)
            l.debug("Too few states (%d/%d) in stash %s.", len(states), self.min, self.src_stash)
            if self.staging_stash:
                l.debug("... retrieving states from staging stash (%s)", self.staging_stash)
                if len(staged_states) > missing and self.select_states is not None:
                    back, stay = self.select_states(staged_states, missing)
                    staged_states = stay
                    states += back
                else:
                    staged_states.sort(key=self.priority_key or self.state_priority)
                    states += staged_states[:missing]
                    staged_states[:missing] = [ ]

        if len(states) > self.max:
            l.debug("Too many states (%d/%d) in stash %s", len(states), self.max, self.src_stash)
            if len(staged_states) > self.max and self.select_states is not None:
                keep, spill = self.select_states(states, self.max)
                staged_states += spill
                states = keep
            else:
                states.sort(key=self.priority_key or self.state_priority)
                staged_states += states[self.max:]
                states[self.max:] = [ ]

        simgr.stashes[self.src_stash] = states
        simgr.stashes[self.staging_stash] = staged_states
        return simgr

    @staticmethod
    def state_priority(state):
        return id(state)
