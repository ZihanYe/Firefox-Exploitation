from . import ExplorationTechnique

class MatchTracer(ExplorationTechnique):
    def __init__(self, guide_state, extra_stopping_func=None, allow_early_stopping=True):
        super(MatchTracer, self).__init__()
        self.guide_state = guide_state
        self.trace = guide_state.history.bbl_addrs.hardcopy
        self.trace_len = len(self.trace)
        # self.trace_step = 0
        self.extr_stopping_func = extra_stopping_func
        self.allow_early_stopping = allow_early_stopping

    def setup(self, simgr):
        # self.project = simgr._project
        simgr.populate('deferred', [])
        simgr.populate('found', [])

        if len(simgr.active) != 1:
            raise Error("MatchTracer is being invoked on a SimulationManager without exactly one active state")
        if not simgr.active[0].has_plugin('tracerHelper'):
            raise Error("MatchTracer is being invoked with a state without tracerHelper plugin")
        # self.trace_step = simgr.active[0].tracerHelper.trace_idx

    def step(self, simgr, stash='active', **kwargs):
        return simgr.step(stash=stash, **kwargs)

    def step_state(self, simgr, state, **kwargs):
        succs_dict = simgr.step_state(state, **kwargs)
        if len(succs_dict[None]) == 0:
            return succs_dict

        sat_succs = []
        if self.extra_stopping_func is not None:
            for s in succs_dict[None]:
                if self.extra_stopping_func(s):
                    succs_dict['found'].append(s)
                else:
                    sat_succs.append(s)
        else:
            sat_succs = succs_dict[None]

        if self.allow_early_stopping and len(succs_dict['found']) > 0:
            return succs_dict

        if not state.tracerHelper.inside_lazy_solver:
            # pick the right successor
            picked = []
            for s in sat_succs:
                s.tracerHelper.trace_idx += 1
                if s.tracerHelper.trace_idx == self.trace_len:
                    print("trace reaching the end")
                    succs_dict['found'].append(s)
                elif self.trace[s.tracerHelper.trace_idx] == int(0xfffffffffffff01e, 16):
                    s.tracerHelper.inside_lazy_solver = True
                    print("continue inside lazy solver")
                    count = 0
                    for c in s.callstack:
                        count += 1
                    s.tracerHelper.goal_call_stack = count
                    picked.append(s)
                elif self.trace[s.tracerHelper.trace_idx] == s.addr:
                    picked.append(s)
            if len(picked) > 1:
                # raise Exception("The state split but several successors have the same (correct) address?")
                print("multiple successors have correct address, why?")
                import IPython; IPython.embed()
            elif len(picked) == 0:
                print("no more state tracable")

            succs_dict[None] = [picked[0]]
            return succs_dict

        # inside lazy solver
        found = []
        normal = []
        for s in sat_succs:
            if s.addr == self.trace[s.tracerHelper.trace_idx + 1] and s.history.jumpkind=='Ijk_Ret':
                count = 0
                for c in s.callstack:
                    count += 1
                if count == s.tracerHelper.goal_call_stack:
                    # s is a return state
                    # check if return value is satisfiable
                    if s.tracerHelper.check_ret_value(s.regs.rax):
                        # continue
                        s.tracerHelper.trace_idx += 1
                        s.tracerHelper.inside_lazy_solver = False
                        s.goal_call_stack = None
                        found.append(s)
                        print("find a good return state")
                        import IPython; IPython.embed()
                    else:
                        succs_dict['unsat'].append(s)
                        print("find a bad return state")
                        import IPython; IPython.embed()
                    continue
            # s is not a return state
            normal.append(s)

        self._random.shuffle(normal)
        if len(found) == 0:
            if len(normal) > 0:
                succs_dict[None] = normal[0]
                succs_dict['deferred'].extend(normal[1:])
            elif len(succs_dict['deferred']) > 0
                # not sat state left..
                # start with one in deferred
                succs_dict[None] = [succs_dict['deferred'].pop()]
            else:
                succs_dict[None] = []
        else:
            self._random.shuffle(found)
            succs_dict[None] = found[0]
            succs_dict['deferred'].extend(found[1:])
            succs_dict['deferred'].extend(normal)

        assert len(succs_dict[None]) <= 1
        return succs_dict
