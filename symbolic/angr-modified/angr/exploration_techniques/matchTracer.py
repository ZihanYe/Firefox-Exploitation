from . import ExplorationTechnique
import random
import logging
log = logging.getLogger("tracer")
log.setLevel('INFO')

class MatchTracer(ExplorationTechnique):
    def __init__(self, guide_state, extra_stopping_func=None, allow_early_stopping=True):
        super(MatchTracer, self).__init__()
        self.guide_state = guide_state
        self.trace = guide_state.history.bbl_addrs.hardcopy
        self.trace_len = len(self.trace)
        # self.trace_step = 0
        self.extra_stopping_func = extra_stopping_func
        self.allow_early_stopping = allow_early_stopping
        self._random = random.Random()
        self._random.seed(10)

    def setup(self, simgr):
        # self.project = simgr._project
        simgr.populate('deferred', [])
        simgr.populate('found', [])

        if len(simgr.active) != 1:
            raise Error("MatchTracer is being invoked on a SimulationManager without exactly one active state")
        if not simgr.active[0].has_plugin('tracerHelper'):
            raise Error("MatchTracer is being invoked with a state without tracerHelper plugin")
        # self.trace_step = simgr.active[0].tracerHelper.trace_idx

    def step(self, simgr, stash='active', **kwargs):
        simgr = simgr.step(stash=stash, **kwargs)
        if len(simgr.stashes['active']) == 0:
            if len(simgr.stashes['deferred']) == 0:
                return simgr
            print("reshelve")
            simgr.stashes['active'].append(simgr.stashes['deferred'].pop())
        return simgr

    def step_state(self, simgr, state, **kwargs):
        if not state.tracerHelper.inside_lazy_solver and state.tracerHelper.trace_idx+1 < self.trace_len and self.trace[state.tracerHelper.trace_idx+1] == 0xfffffffffffff01e:
            state.tracerHelper.inside_lazy_solver = True
            state.tracerHelper.trace_idx += 1
            log.info("continue inside lazy solver")
            state.tracerHelper.goal_call_stack = len(state.callstack) -1

        succs_dict = simgr.step_state(state, **kwargs)
        if 'found' not in succs_dict:
            succs_dict['found'] = []
        if 'deferred' not in succs_dict:
            succs_dict['deferred'] = []

        if None not in succs_dict:
            return succs_dict

        sat_succs = []
        if self.extra_stopping_func is not None:
            for s in succs_dict[None]:
                if self.extra_stopping_func(s):
                    succs_dict['found'].append(s)
                else:
                    sat_succs.append(s)
        else:
            sat_succs = succs_dict[None]

        if self.allow_early_stopping and len(succs_dict['found']) > 0:
            return succs_dict

        if not state.tracerHelper.inside_lazy_solver:
            # print("not inside lazy solver with ", len(sat_succs), " sat successors")
            # pick the right successor
            picked = []
            for s in sat_succs:
                s.tracerHelper.trace_idx += 1
                if s.tracerHelper.trace_idx == self.trace_len:
                    log.info("trace reaching the end")
                    succs_dict['found'].append(s)
                elif self.trace[s.tracerHelper.trace_idx] == s.addr:
                    picked.append(s)

            if len(picked) > 1:
                log.error("multiple successors have correct address, why?")
                raise Exception("The state split but several successors have the same (correct) address?")
            elif len(picked) == 0:
                log.info("no more state tracable")
                succs_dict[None] = []
                return succs_dict

            succs_dict[None] = [picked[0]]
            return succs_dict

        # inside lazy solver
        found = []
        normal = []
        for s in sat_succs:
            # print("inside lazy solver with ", len(sat_succs), " sat successors")
            if len(s.callstack) < s.tracerHelper.goal_call_stack:
                log.error("something went wrong about the trace")
                import IPython; IPython.embed()
                continue
            elif len(s.callstack) == s.tracerHelper.goal_call_stack:
                if s.addr == self.trace[s.tracerHelper.trace_idx + 1] and s.history.jumpkind=='Ijk_Ret':
                    # s is a return state
                    # check if return value is satisfiable
                    if s.tracerHelper.check_ret_value(s.regs.rax):
                        # continue
                        s.tracerHelper.trace_idx += 1
                        s.tracerHelper.inside_lazy_solver = False
                        s.goal_call_stack = None
                        found.append(s)
                        log.info("find a good return state")
                    else:
                        succs_dict['unsat'].append(s)
                        log.info("find a bad return state")
                    continue
                else:
                    log.error("something went wrong")
                    import IPython; IPython.embed()
                    continue
            # s is not a return state
            normal.append(s)

        self._random.shuffle(normal)
        if len(found) == 0:
            if len(normal) > 0:
                succs_dict[None] = [normal[0]]
                succs_dict['deferred'].extend(normal[1:])
            elif len(succs_dict['deferred']) > 0:
                # not sat state left..
                # start with one in deferred
                succs_dict[None] = [succs_dict['deferred'].pop()]
            else:
                succs_dict[None] = []
        else:
            self._random.shuffle(found)
            succs_dict[None] = [found[0]]
            succs_dict['deferred'].extend(found[1:])
            succs_dict['deferred'].extend(normal)
            import IPython; IPython.embed()

        assert len(succs_dict[None]) <= 1
        return succs_dict
