from . import SimConcretizationStrategy

class SimConcretizationStrategyObjectSingle(SimConcretizationStrategy):
    """
    Concretization strategy that:
            We only deal with address of form base + offset, where only offset is symbolic and unconstrained.
            if only base:
                fall through to SimConcretizationStrategyObject
            if base and offset
                1. both base and offset are unique -> should handled by previous strayrgy
                2. base is unique and offset is unconstrained -> concretize offset
                3. otherwise fall through.
    """

    """
    choices of concretization of offset in the case that base is unique but offset is unconstrained:
        MIN, MAX, ANY (concretize up to limit number of random result)
    """

    def __init__(self, offset_concretization=["MIN", "ANY"], limit=2, **kwargs):
        super(SimConcretizationStrategyObjectSingle, self).__init__(**kwargs)
        self._limit = limit
        self._offset_concretization = offset_concretization

    def _check(self, memory, addr, constrained_parts):
        for c in constrained_parts:
            # check if addr2 is the base address
            index = memory.state.record.check_inside_obj_index(c)
            if index is not None:
                # concrete or unique base
                # we want concretize the offset
                # prevent offset being too big
                obj = memory.state.record.obj_mem[index]
                constraint = memory.state.solver.And(addr > obj[0], addr < obj[1])
                solutions = []
                try:
                    if 'MIN' in self._offset_concretization:
                        solutions.extend(self._min(memory, addr, extra_constraints=[constraint]))
                    if 'MAX' in self._offset_concretization:
                        solutions.extend(self._max(memory, addr, extra_constraints=[constraint]))
                    if 'ANY' in self._offset_concretization:
                        solutions.extend(self._eval(memory, addr, self._limit - len(solutions), extra_constraints=[constraint]))
                except:
                    print("[-] Fail to concretize the offset")
                    raise('Failure in concretization with SimConcretizationStrategyObjectSingle')
                return solutions
        # no unique base address found, fallthrough
        return None

    def _concretize(self, memory, addr):
        unconstrained, constrained = self._separate_unconstrained(memory, addr, [])
        return self._check(memory, addr, constrained)

    def _separate_unconstrained(self, memory, addr, constrained):
        if addr.op != '__add__':
            return addr, constrained
        addr1 = addr.args[0]
        addr2 = addr.args[1]
        addrs1 = self._eval(memory, addr1, 2)
        addrs2 = self._eval(memory, addr2, 2)
        if len(addrs1) > 1 and len(addrs2) > 1:
            return None
        if len(addrs1) == 1:
            return self._separate_unconstrained(memory, addr2, constrained+[addr1])
        if len(addrs2) == 1:
            return self._separate_unconstrained(memory, addr1, constrained+[addr2])
        return None
