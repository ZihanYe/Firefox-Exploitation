from . import SimConcretizationStrategy

class SimConcretizationStrategyObjectHeap(SimConcretizationStrategy):
    """
    Concretization strategy that deals the case when base address is unconstrained
    allocate an object on heap
    """

    def __init__(self, max_obj_size = 0x500, max_offset = 0x500, reserved_mem=0x200, **kwargs):
        super(SimConcretizationStrategyObjectHeap, self).__init__(**kwargs)
        self._max_obj_size = max_obj_size
        self._max_offset = max_offset
        self._reserved_mem = reserved_mem

    def _separate_constrained(self, memory, addr):
        if addr.op != '__add__':
            return [addr], [], 0
        constrained = []
        offset = 0
        unconstrained = []
        for a in addr.args:
            vs = self._eval(memory, a, 2)
            if len(vs) == 1:
                constrained.append(a)
                offset += vs[0]
            else:
                un, c, off = self._separate_constrained(memory, a)
                unconstrained.extend(un)
                constrained.extend(c)
        return unconstrained, constrained, offset

    def _concretize(self, memory, addr):
        try:
            unc, c, offset = self._separate_constrained(memory, addr)
            obj_size = max(offset, self._max_obj_size)

            start_addr = memory.state.heap._malloc(obj_size + self._reserved_mem)
            end_addr = start_addr + self._reserved_mem + obj_size
            memory.state.record.add_obj_mem((start_addr, end_addr))
            if memory.state.has_plugin('controlledObjectMap'):
                memory.state.controlledObjectMap.add_an_object(start_addr+self._reserved_mem, (start_addr, end_addr))
            return [start_addr + self._reserved_mem + offset]
        except:
            print("[-] Exception in object concretization with SimConcretizationStrategyObjectHeap")
            return None
