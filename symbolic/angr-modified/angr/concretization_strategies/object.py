from . import SimConcretizationStrategy

class SimConcretizationStrategyObject(SimConcretizationStrategy):
    """
    Concretization strategy that:
        1. try to resolve to one solution
        2. if not, return arbitrary address but ensure that all addresses returned are at least max_obj_size * 2 appart from each other
    """

    def __init__(self, max_obj_size = 0x200, dummy_memory_start=0xfffffffff0000000, dummy_memory_end=0xffffffffffffffff, **kwargs):
        super(SimConcretizationStrategyObject, self).__init__(**kwargs)
        self._memory_end = dummy_memory_end
        self._max_obj_size = max_obj_size
        # self._unused_pointer = dummy_memory_start
        #if self._unused_pointer > self._memory_end:
        #    print("[-] Dummy memory region used up")
        #    import IPython; IPython.embed()

    def _symbolic_base_concrete_offset(self, addr):
        if addr.op == '__add__':
            children = list(addr.children_asts())
            if children[0].symbolic and not children[1].symbolic:
                return children[0], children[1]
            elif children[1].symbolic and not children[0].symbolic:
                return children[1], children[0]
        return None

    def _guess_const_offset(self, memory, addr):
        offset = 0
        if addr.op == '__add__':
            children = addr.leaf_asts()
            for c in children:
                if isinstance(c,int) or not c.symbolic:
                    offset += memory.state.solver.eval(c)
        return offset

    def _concretize(self, memory, addr):
        addrs = self._eval(memory, addr, 2)
        if len(addrs) == 1:
            return addrs
        try:
            # allocate a new object:
            '''
            new object is in the range:

                ...lb - max_obj_size ++++++ lb +++ solutions[0] +++++ up ++++++ up + max_obj_size ....

                where: up = lb + max_obj_size,
                Hopefully the base address of this object is within [lb - max_obj_size, up + max_obj_size]
            '''
            unused = memory.state.record.unused_pointer
            if unused > self._memory_end:
                print("[-] Dummy memory region used up")
                import IPython; IPython.embed()

            obj_size = max(self._max_obj_size,self._guess_const_offset(memory, addr))
            addr_lower_bound = unused + obj_size
            addr_upper_bound = addr_lower_bound + obj_size

            constraint = memory.state.solver.And(addr >= addr_lower_bound, addr < addr_upper_bound)
            solutions = self._eval(memory, addr, 1, extra_constraints=[constraint])
            if not solutions:
                solutions = None
                print("[-] SimConcretizationStrategyObject fails to concretize the address, fall back to other strategies")
            else:
                memory.state.record.unused_pointer += obj_size *3
                memory.state.record.add_obj_mem((unused, addr_upper_bound+obj_size))
                print('[+] new fake object allocated')
            return solutions
        except:
            print("[-] Exception in object concretization")
            import IPython; IPython.embed()

    def copy(self):
        return SimConcretizationStrategyObject(
            max_obj_size = self._max_obj_size,
            dummy_memory_end=self._memory_end,
        )
