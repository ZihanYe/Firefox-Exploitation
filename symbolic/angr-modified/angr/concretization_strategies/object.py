from . import SimConcretizationStrategy

class SimConcretizationStrategyObject(SimConcretizationStrategy):
    """
    Concretization strategy that deals the case when base address is unconstrained

    return arbitrary address but ensure that all addresses returned are at least max_obj_size * 2 appart from each other
    """

    def __init__(self, max_obj_size = 0x200, dummy_memory_end=0xffffffffffffffff, **kwargs):
        super(SimConcretizationStrategyObject, self).__init__(**kwargs)
        self._memory_end = dummy_memory_end
        self._max_obj_size = max_obj_size

    def _guess_const_offset(self, memory, addr):
        offset = 0
        if addr.op == '__add__':
            children = addr.args
            for c in children:
                if isinstance(c,int) or not c.symbolic:
                    offset += memory.state.solver.eval(c)
        return offset

    def _concretize(self, memory, addr):
        try:
            # allocate a new object:
            '''
            new object is in the range:

                ...lb - max_obj_size ++++++ lb +++ solutions[0] +++++ up ++++++ up + max_obj_size ....

                where: up = lb + max_obj_size,
                Hopefully the base address of this object is within [lb - max_obj_size, up + max_obj_size]
            '''
            unused = memory.state.record.unused_pointer
            if unused > self._memory_end:
                print("[-] Dummy memory region used up")
                import IPython; IPython.embed()

            obj_size = max(self._max_obj_size,self._guess_const_offset(memory, addr))
            addr_lower_bound = unused + obj_size
            addr_upper_bound = addr_lower_bound + obj_size

            constraint = memory.state.solver.And(addr >= addr_lower_bound, addr < addr_upper_bound)
            try:
                solutions = self._eval(memory, addr, 1, extra_constraints=[constraint])
            except:
                solutions = None
                print("[-] Exception in object concretization with SimConcretizationStrategyObject")

            if not solutions or len(solutions) == 0:
                solutions = None
                print("[-] SimConcretizationStrategyObject fails to concretize the address, fall back to other strategies")
            else:
                memory.state.record.unused_pointer += obj_size *3
                memory.state.record.add_obj_mem((unused, addr_upper_bound+obj_size))
                print('[+] new fake object allocated')
            return solutions
        except:
            print("[-] Exception in object concretization with SimConcretizationStrategyObject")
            import IPython; IPython.embed()

    def copy(self):
        return SimConcretizationStrategyObject(
            max_obj_size = self._max_obj_size,
            dummy_memory_end=self._memory_end,
        )
