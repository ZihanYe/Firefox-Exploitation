from . import SimConcretizationStrategy

class SimConcretizationStrategyObjectMax(SimConcretizationStrategy):
    """
    Concretization strategy that:
        try max memory address possible but also avoiding overlapping with other memory object
    """

    def __init__(self, max_space_reserved = 0x600, **kwargs):
        super(SimConcretizationStrategyObjectMax, self).__init__(**kwargs)
        self._max_space_reserved = max_space_reserved

    def _concretize(self, memory, addr):
        existing_objs = memory.state.record.obj_mem
        obj_lower_bound = addr - int(self._max_space_reserved/2)
        obj_upper_bound = addr + int(self._max_space_reserved/2)

        constraints = []
        for (obegin, oend) in existing_objs:
            # they should not overlap
            constraints.append(memory.state.solver.Or(obj_upper_bound < obegin, obj_lower_bound > oend))
        try:
            solutions = self._eval(memory, addr, 1, extra_constraints=constraints)
        except:
            solutions = None
            print("[-] Exception in object concretization with SimConcretizationStrategyObjectMax")
            import IPython; IPython.embed()

        if not solutions or len(solutions) == 0:
            solutions = None
            print("[-] SimConcretizationStrategyObjectMax fails to concretize the address, fall back to other strategies")
        else:
            memory.state.record.add_obj_mem((solutions[0]-int(self._max_space_reserved/2), solutions[0]+int(self._max_space_reserved/2)))
            print('[+] new fake object allocated')
        return solutions

    def copy(self):
        return SimConcretizationStrategyObjectMax(
            max_space_reserved = self._max_space_reserved,
        )
