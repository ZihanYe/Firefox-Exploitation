# Primitive search with symbolic execution

## Context

To exploit a UAF vulnerability, we want to use the dangling pointer after the vulnerable object is freed, either by reaching a control hijack or a write-what-where primitive, while avoiding any crash happening before the primitive.

This tool extends angr and uses it to perform symbolic execution, starting at the point of dangling pointer occurrence until the dangling pointer is no longer accessible.

## Symbolic exploitation

### Symbolic bytes in freed object

Before starting symbolic execution, we set symbolic value to each byte in the freed object, assuming that we have full control over the region of freed object.

### (Lazy) Memory control propagation

Assuming that since we can control the whole freed region, we can also place inside the freed region pointers to another object, which we also have full control of. So we might have a chain of controlled object, referenced via pointers, starting from the initial freed object.

These objects are reachable via the dangling pointer through pointers, and hence maybe read/written. After heap spraying, when the program accesses one of the controlled objects through dangling pointers and possibly a chain of other pointers, it is possible to reach an exploitable primitive.




### Address Concretization Strategy

When a symbolic address is read from/written to,


### Symbolic Call Emulation


### Record of access to controlled memory


## Usage


## Example
