# Primitive search with symbolic execution

## Context

To exploit a UAF vulnerability, we want to use the dangling pointer after the vulnerable object is freed, either by reaching a control hijack or a write-what-where primitive, while avoiding any crash happening before the primitive.

This tool extends angr to fit the purpose for primitive search in exploiting UAF vulnerability. It performs symbolic execution, starting at the point of dangling pointer occurrence until the dangling pointer is no longer accessible, presenting all memory accesses related to the freed object and potential primitives as a consequence of the given UAF vulnerability.

## Symbolic exploitation

### Symbolic bytes in freed object

Before starting symbolic execution, we set symbolic value to each byte in the freed object, assuming that we have full control over the region of freed object.

### Controlled Memory propagation

Assuming that since we can control the whole freed region, we can also place inside the freed region pointers to another object, which we also have full control of. So we might have a chain of controlled objects, referenced via pointers, starting from the initial freed object.

These objects are reachable via the dangling pointer directly or indirectly, and hence maybe read/written. After heap spraying, when the program accesses one of the controlled objects through dangling pointers, it is possible to reach an exploitable primitive.

To find out what objects are accessed by the dangling pointer, we do controlled memory propagation during symbolic execution:

Suppose we have freed region of size ```0x200``` starting from ```0x00005569804e00c0```. At the beginning of the symbolic execution, we set a symbolic variable for each of them, say ```S0... S199```.

Suppose at some time, ```S56...S63``` is read into ```rbx``` and then an instruction
```
mov rax qword ptr [rbx + 0x1c]
```
is met, which read memory content at address ```S56...S63 + 0x1c```. This is a **dereference of symbolic pointer** and in particular **a read from symbolic address**.

We deal with this case by allocating a "fake object" in memory where the program usually does not touch. We add constraints to make ```S56...S63 + 0x1c``` points to somewhere in this region, say ```0xfffffffff000001c```. Then we store 8 bytes of symbolic variables ```V0 ... V7``` in memory address starting from ```0xfffffffff000001c```. After this, execution is resumed and ```rax``` now holds ```V0 ... V7```.


### Symbolic Call Emulation

When there is a call to a function with symbolic address, we emulate the function and return a symbolic variable. This relies on the assumption that we might be able to use the control hijack to execute a function with controlled return value.

Symbolic return values are tracked after returning from function to see how it affects the program execution. It might be the case where the return value is a pointer to another object, or pointer to another function...

### Record of access to controlled memory



## Usage

Given a UAF vulnerability, in GDB, find out where the freed object is. Break at the point when it returns to the context of dangling pointer after free and produce the core dump file using:
```
gcore
```

In a python script,
```
import executor
e = executor.Executor(/path/to/core/file, step_limit=300, stop_when_active_more_than=500)
e.run(uaf_object_base=<addr_of_freed_obj>, uaf_object_size=<size>, context_end=<context_end>)
```

There are more options to be passed in to ```executor```:
```
class Executor(util.Util, bpHandlers.BpHandlers, explore.Explore):
    def __init__(self, core_file,
                step_limit=None,
                stop_when_primtive_found=None,
                stop_when_active_more_than=None,
                stop_when_write_primtive_found=False,
                stop_when_control_hijack_found=False,
                continue_with_write_primitive=False,
                continue_with_control_hijack=True):
```

For example:
```
e = executor.Executor(/path/to/core/file, stop_when_active_more_than=500, continue_with_write_primitive=True, continue_with_control_hijack=True)
```

This executor will stop when there are more than 500 active state in simulation manager. When a state reaches a write primitive, the executor stores the state but does not continue symbolic execution with successors of that state. When a state reaches a control execution, the executor continue with symbolic call emulation.

## Example
