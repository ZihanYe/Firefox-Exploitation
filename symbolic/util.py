import angr
from visualization.dumpInfo import DumpInfo
from analyse.primitiveExplore import PrimitiveExplore
import sys

class Util:
    def dump_state(self,state):
        ap = self.ap
        try:
            print('-----start dump state-----')
            # print('state addr: ', state.addr)
            print('**registers**')
            self.dump_reg(state)
            print('**instructions**')
            if isinstance(state.addr, int) or not state.addr.symbolic:
                irsb = ap.factory.block(state.addr).vex
                cap = ap.factory.block(state.addr).capstone
                irsb.pp()
                cap.pp()
            # print('**state**')
            # print('variable: ', list(state.solver.get_variables()))
            # print('constraints: ', list(state.solver.constraints))
            # print('tainted: ', state.record.tainted_mem)
            print('-----end dump state-----')
        except angr.errors.SimEngineError:
            print('angr.errors.SimEngineError')
        except angr.errors.SimValueError:
            print('angr.errors.SimValueError:')

    def dump_reg(self, state):
        print( 'rax:', state.regs.rax,' r8:', state.regs.r8)
        print( 'rbx:', state.regs.rbx, ' r9:', state.regs.r9)
        print( 'rcx:', state.regs.rcx,' r10:', state.regs.r10)
        print( 'rdx:', state.regs.rdx,' r11:', state.regs.r11)
        print('rsi:', state.regs.rsi, ' r12:', state.regs.r12)
        print('rdi:', state.regs.rdi, ' r13:', state.regs.r13)
        print('rsp:', state.regs.rsp, ' r14:', state.regs.r14)
        print('rbp:', state.regs.rbp, ' r15:', state.regs.r15)
        print( 'gs:', state.regs.gs)
        return

    def dump_one_reg(self, state, name):
        try:
            print(name, state.regs.get(name))
        except:
            print("no such register")

    def dump_instr(self, simgr):
        for ins in self.ap.factory.block(simgr.active[0].addr).capstone.insns:
            print(ins)

    def dump_state_result(self, state, interact = True, color=True):
        self.dump_state(state)
        d = DumpInfo(self.ap, state, self.uaf_object_base, self.uaf_object_size, color=color)
        if interact:
            import IPython; IPython.embed()
        else:
            d.dump_all()

    def debug_simgr(self, simgr):
        print('-----start dump simulator-----')
        count = 0;
        print('active:')
        for state in simgr.stashes['active']:
            self.dump_state(state)
            count += 1
        print("active state: ", count)
        print('-----end dump simulator-----')

    def debug_executor(self, nPrimitive=5, color=True):
        print('-----start dump executor-----')
        print('Step: ', self.step)
        e = PrimitiveExplore(self.ap, self.simgr, self.write_primitive, self.control_hijack)
        e.dump_stats()

        print('*' * 100)
        print('Some write primitives: ')
        e.sort_by_obj_count(type='W')
        wstates = e.get_states(type='W', limit=nPrimitive)
        i = 0
        for s in wstates:
            print("Write primitive ", str(i))
            print('*' * 100)
            self.dump_state_result(s, interact=False, color=color)
            i += 1

        print('*' * 100)
        print('Some control hijacks: ')
        e.sort_by_obj_count(type='C')
        cstates = e.get_states(type='C', limit=nPrimitive)
        i = 0
        for s in cstates:
            print("Control hijack ", str(i))
            print('*' * 100)
            self.dump_state_result(s, interact=False, color=color)
            i += 1
        print('-----end dump executor-----')

    def dump_executor_into_file(self, file):
        stdout = sys.stdout
        sys.stdout = open(file, 'w')
        # print
        self.debug_executor(color=False)
        # end
        sys.stdout = stdout


    def retrive_addr(self, bv, prefix, addr_size=64):
        tindex = str(bv).find(prefix)
        if tindex != -1:
            endindex = str(bv)[tindex+len(prefix):].find('_')
            memaddr = str(bv)[tindex+len(prefix):(tindex+len(prefix)+ endindex)]
            addr = int('0x' + memaddr, 16)
            return addr
        else:
            log.error('[-] WARNING: Unable to find addresss from the name '+ str(bv))
            return None
