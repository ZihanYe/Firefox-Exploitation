import angr
from colorama import Fore, Back, Style
from tabulate import tabulate

class DumpInfo:
    def __init__(self, state, uaf_object_base, uaf_object_size):
        self.state = state
        self.uaf_object_base = uaf_object_base
        self.uaf_object_size = uaf_object_size

        self.obj_mem = self.state.record.obj_mem
        self.symbolic_pointers = self.state.record.symbolic_pointer

        # objects
        m, u = self.__get_point_matrix()
        self.matrix = m
        self.unresolved_ptrs = u

        self.name = ["OBJ_"+ str(i) for i in range(len(self.obj_mem))]
        for i in range(len(self.obj_mem)):
            if self.obj_mem[i][0] == uaf_object_base:
                self.name[i] = "UAF_OBJ"

        # variables
        self.vars = list(self.state.solver.all_variables)
        l, uv = self.__variable_map()
        self.vars_in_objs = l
        self.unresolved_vars = uv


    def dump_state_result(self):
        # objects
        for i in range(len(self.obj_mem)):
            self.dump_object_snapshot(i)

        # constraints
        print(Fore.BLUE + '*' * 100)
        print(Fore.BLUE + 'constraints:             ')
        print(Fore.CYAN + self.state.solver.constraints)

        # unresolved ptrs
        print(Fore.BLUE + '*' * 100)
        print(Fore.BLUE + 'Symbolic pointers that we are not sure which object it belongs to:')
        table = []
        for (s,p) in self.unresolved_ptrs:
            table.append([hex(s), hex(p)])
        print(Fore.CYAN + tabulate(table, headers=["address","points to"]))

        # unresolved vars
        print(Fore.BLUE + '*' * 100)
        print(Fore.BLUE + 'Variables that we are not sure which object it belongs to:')
        table = []
        for (v,addrs) in self.unresolved_vars:
            addrs_str = list(map(lambda x: hex(x), addrs))
            table.append([v, ','.join(addr_str)])
        print(Fore.CYAN + tabulate(table, headers=["variable","address"]))

        # unresolved tainted mem

        # symbolic return


    def dump_memory_snapshot(self):
        pass

    def dump_object_snapshot(self, index):
        obj = self.obj_mem[index]
        # points_to = self.__get_sorted_symbolic_pointers_inside(obj)
        base = self.__possible_start(index)

        # print
        print(Fore.BLUE + '*' * 100)
        print(Fore.BLUE + 'object:                 ', self.name[index])
        print(Fore.BLUE + '(possible) base address ', base)
        print(Fore.BLUE + 'maximum memory range    ', '[ ', hex(obj[0]), ' , ', hex(obj[1]), ' ]')
        print(Fore.BLUE + 'contain pointers:       ')
        # offset, points to
        table = []
        for i in range(len(self.obj_mem)):
            if self.matrix[index][i] is not None:
                (s,p) = self.matrix[index][i]
                table.append([hex(s-base), self.name[i]])
        print(Fore.CYAN + tabulate(table, headers=["offset","points to"]))

        # variables
        print(Fore.BLUE + 'contain variables:      ')
        vtable = []
        for (v, addrs) in self.vars_in_objs[index]:
            offsets = list(map(lambda x: hex(x-base), addrs))
            offsets.sort()
            vtable.append([v, ','.join(offsets)])
        print(Fore.CYAN + tabulate(vtable, headers=["variable","offsets"]))


    def __get_sorted_symbolic_pointers_inside(self, obj):
        ptrs = []
        for (s,p) in self.symbolic_pointers:
            if s >= obj[0] and s < obj[1]:
                ptrs.append((s, p))
        ptrs.sort(reverse=True)
        return ptrs

    def __inside(self, addr):
        for i in range(len(self.obj_mem)):
            if addr >= self.obj_mem[i][0] and addr < self.obj_mem[i][1]:
                return i
        return None

    def __sort_pointers_by_objs(self, obj_mem, symbolic_pointers):
        objects = {}
        unresolved = []
        for (s,p) in symbolic_pointers:
            found = False
            for o in obj_mem:
                if s >= o[0] and s < o[1]:
                    if o[0] not in objects:
                        objects[o[0]] = [(s,p)]
                    else:
                        objects[o[0]].append((s,p))
                    found = True
                    break

            if not found:
                unresolved.append((s,p))

        return objects, unresolved

    def __get_point_matrix(self):
        n = len(self.obj_mem)
        matrix = [[None for i in range(n)] for j in range(n)]
        unresolved = []
        for (s,p) in self.symbolic_pointers:
            pointed_by = None
            for i in range(n):
                if s >= self.obj_mem[i][0] and s < self.obj_mem[i][1]:
                    pointed_by = i
                    break

            point_to = None
            for i in range(n):
                if p >= self.obj_mem[i][0] and p < self.obj_mem[i][1]:
                    point_to = i
                    break

            if pointed_by is not None and point_to is not None:
                matrix[pointed_by][point_to] = (s,p)
            else:
                unresolved.append((s,p))

        return matrix, unresolved

    def __possible_start(self, index):
        if self.obj_mem[index][0] == self.uaf_object_base:
            # it is the uaf object
            return self.obj_mem[index][0]

        start = self.obj_mem[index][1]
        found = False
        for i in range(len(self.obj_mem)):
            if self.matrix[i][index] is not None and self.matrix[i][index][1] < start:
                # possible base address
                start = self.matrix[i][index][1]
                found = True
        if not found:
            start = self.obj_mem[index][0]
        return start

    def __variable_map(self):
        vars_in_objs= [[] for i in range(len(self.obj_mem))]
        unresolved = []
        for v in self.vars:
            # get addrs
            addrs = list(self.state.memory.addrs_for_hash(hash(v)))
            if len(addrs) > 0:
                addr = min(addrs)
                index = self.__inside(addr)
                if index is not None:
                    vars_in_objs[index].append((v, addrs))
                else:
                    unresolved.append((v, addrs))
            else:
                unresolved.append((v, addrs))
        return vars_in_objs, unresolved
