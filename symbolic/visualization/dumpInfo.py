import angr
from colorama import Fore, Back, Style
from tabulate import tabulate
from analyse.stateAnalyse import StateAnalyse

class DumpInfo:
    def __init__(self, proj, state, uaf_object_base, uaf_object_size, color=True):
        # color scheme:
        global HEADER; global CONTENT; global WARNING; global NORMAL;
        global CONTROL; global WRITE; global RETURN; global RESET;

        if not color:
            HEADER = ""; CONTENT = ""; WARNING = ""; NORMAL=""; CONTROL = ""; WRITE = ""; RETURN = ""; RESET = ""
        else:
            HEADER = Fore.BLUE + Style.BRIGHT; CONTENT = Fore.CYAN +Style.NORMAL;
            WARNING = Fore.RED + Style.BRIGHT; NORMAL = Fore.WHITE;
            CONTROL = Fore.RED; WRITE = Fore.YELLOW
            RETURN = Fore.MAGENTA; RESET = Style.RESET_ALL


        self.proj = proj
        self.state = state
        self.uaf_object_base = uaf_object_base
        self.uaf_object_size = uaf_object_size

        self.obj_mem = self.state.record.obj_mem
        self.name = ["OBJ_"+ str(i) for i in range(len(self.obj_mem))]

        self.symbolic_pointers = self.state.record.symbolic_pointer
        self.vars = list(self.state.solver.all_variables)

        analyse = StateAnalyse(self.state, self.uaf_object_base, self.uaf_object_size)

        # result to be analysed
        self.matrix = analyse.matrix
        self.unresolved_ptrs = analyse.unresolved_ptrs
        self.vars_in_objs = analyse.vars_in_objs
        self.unresolved_vars = analyse.unresolved_vars
        self.obj_start = analyse.obj_start

    '''
    print
    '''

    def dump_all(self):
        self.dump_memory_snapshot()
        self.dump_state_info()
        self.dump_execution_history()

    '''
    State related information:

    '''
    def dump_state_info(self):
        # primitive
        print(HEADER + '*' * 100)
        primitive = self.state.record.primitive
        if primitive is not None:
            if primitive['type'] == 'WWW':
                print(WARNING  + 'This is a write primitive')
                print('You have full control of what and where to write')
                print(HEADER + 'It happens at: ', primitive['inst'])
                print('Write ', primitive['write_size'], ' bytes to ', primitive['write_to'])
                print('with expression :', primitive['value'])

            elif primitive['type'] == 'CONTROL':
                print(WARNING + 'This is a control hijack')
                print('You are calling a function with controlled address')
                print(HEADER + 'It happens at: ', primitive['call_from'])
                print('Calling ', primitive['call'])

            elif primitive['type'] == 'JUMP':
                print(WARNING + 'This is a control hijack')
                print('You are jumping to a controlled address')
                print(HEADER + 'It happens at: ', primitive['jump_from'])
                print('Jumping to ', primitive['jump_to'])

            else:
                print(WARNING+ "Unknown type of primitive")

        # call stack
        self.dump_call_stack()
        # constraints
        self.dump_constraints()

        # symbolic return
        print(HEADER + '*' * 100)
        print('Variables used as return values of symbolic calls: ')
        for v in self.state.record.sym_call_ret_values:
            print(CONTENT, v)

        print(RESET)


    def dump_constraints(self):
        print(HEADER + '*' * 100)
        print('constraints:             ')
        index = 0
        for c in self.state.solver.constraints:
            print(CONTENT + str(index)+ " ", c)
            index += 1
        print(RESET)

    def dump_execution_history(self, print_constraints = False, print_regs=False):
        print(HEADER + '*' * 100)
        print("We've logged: ")
        print("         taint_mem:          write with controlled value ")
        print("         read_taint:         read from tainted memory ")
        print("         call:               call with controlled function address ")
        print("         jump:               call with controlled destination address ")
        print("         write_ret_val:      write return value to memory ")
        print("         deref_ret_val_w:    dereference returned pointer for write ")
        print("         deref_ret_val_r:    dereference returned pointer for read ")

        print('*' * 100)
        print('Execution history:        '+ RESET)

        for i in range(len(self.state.record.history)):
            self.dump_a_history(i, print_constraints)
            i += 1
        print(RESET)

    def dump_a_history(self, index, print_constraints= False, print_regs=False):
        h = self.state.record.history[index]
        color = NORMAL
        if h['access'] == 'taint_mem':
            color = WRITE
        elif h['access'] == 'call' or h['access'] == 'jump':
            color = CONTROL
        elif h['access'] in ['write_ret_val', 'deref_ret_val_w', 'deref_ret_val_r']:
            color = RETURN

        print(color + str(index) + ': ')
        print(color + '-' * 100)
        for k in h:
            if ((print_constraints and k =='constraints') or k != 'constraints') and k != 'regs':
                v = h[k]
                if isinstance(v, int):
                    v = hex(v)
                print(color + k.ljust(15, ' '), h[k])

        if print_regs and 'regs' in h:
            self.__print_reg_table(h['regs'])

        print(color + '-' * 100)
        print(RESET)

    def dump_call_stack(self, with_instr= False):
        print(HEADER+ "Call Stack:")
        trace = [x.func_addr for x in self.state.callstack]
        for i in range(len(trace)-1):
            print(HEADER + '-' * 100)
            print('At ', hex(trace[i]))
            self.proj.factory.block(trace[i]).capstone.pp()
        print(HEADER + '-' * 100 + RESET)

    '''
    Memory related information
    '''

    def dump_memory_snapshot(self):
        # objects
        for i in range(len(self.obj_mem)):
            self.dump_object_snapshot(i)

        # unresolved ptrs
        print(HEADER + '*' * 100)
        print('Symbolic pointers that we are not sure which object it belongs to:')
        table = []
        for (s,p) in self.unresolved_ptrs:
            table.append([hex(s), hex(p)])
        print(CONTENT + tabulate(table, headers=["address","points to"]))
        print(CONTENT + '-' * 50)
        if len(self.state.record.unresolved_symbolic_pointer) > 0:
            table = []
            for (s,p) in self.state.record.unresolved_symbolic_pointer:
                table.append([s, hex(p)])
            print(CONTENT + tabulate(table, headers=["symbol","points to"]))

        # unresolved vars
        print(HEADER + '*' * 100)
        print('Variables that we are not sure which object it belongs to:')
        if len(self.unresolved_vars) > 0:
            table = []
            for (v,addr) in self.unresolved_vars:
                # addrs_str = list(map(lambda x: hex(x), addrs))
                if addr is not None:
                    table.append([v, hex(addr)])
                else:
                    table.append([v, ""])
            print(CONTENT + tabulate(table, headers=["variable","address"]))
        else:
            print(CONTENT + 'None')

        # unresolved tainted mem
        # TODO:
        print(RESET)


    def dump_object_snapshot(self, index):
        obj = self.obj_mem[index]
        base = self.obj_start[index]
        is_uaf = (base == self.uaf_object_base)

        # print
        print(HEADER + '*' * 100)
        print('object:                 ', self.name[index])
        print('(possible) base address ', hex(base))
        print('maximum memory range    ', '[ ', hex(obj[0]), ' , ', hex(obj[1]), ' ]')
        print(' ')
        print('contains pointers:      ')
        # offset, points to
        table = []
        for i in range(len(self.obj_mem)):
            for (s,p) in self.matrix[index][i]:
                table.append([hex(s-base), self.name[i], hex(p-self.obj_start[i])])
        if len(table) > 0:
            print(CONTENT + tabulate(table, headers=["offset","points to", "offset in target"]))
        else:
            print(CONTENT + "   No pointers     ")
        print(' ')
        # variables
        if not is_uaf:
            print(HEADER + 'contains variables:     ')
            vtable = []
            for (v, addr) in self.vars_in_objs[index]:
                # offsets = list(map(lambda x: hex(x-base), addrs))
                # offsets.sort()
                offset = hex(addr-base)
                vtable.append([v, offset])
            if len(vtable) > 0:
                print(CONTENT + tabulate(vtable, headers=["variable","offsets"]))
            else:
                print(CONTENT + "   No variables    ")
        else:
            print(HEADER + 'This is the UAF object, all bytes of it are symbolic variables')
            print('Object size: ', hex(obj[1] - obj[0]))
            print('contains variables:     ')
            print(CONTENT, self.vars_in_objs[index][0][0], " ... ", self.vars_in_objs[index][len(self.vars_in_objs[0])-1][0])

        print(RESET)

    def __print_reg_table(regs):
        print(CONTENT + 'Registers: ')
        print(CONTENT + '*' * 50)
        print( 'rax:', regs.rax,' r8:', regs.r8)
        print( 'rbx:', regs.rbx, ' r9:', regs.r9)
        print( 'rcx:', regs.rcx,' r10:', regs.r10)
        print( 'rdx:', regs.rdx,' r11:', regs.r11)
        print('rsi:', regs.rsi, ' r12:', regs.r12)
        print('rdi:', regs.rdi, ' r13:', regs.r13)
        print('rsp:', regs.rsp, ' r14:', regs.r14)
        print('rbp:', regs.rbp, ' r15:', regs.r15)
        print( 'gs:', regs.gs)
        print(RESET)

    def __get_sorted_symbolic_pointers_inside(self, obj):
        ptrs = []
        for (s,p) in self.symbolic_pointers:
            if s >= obj[0] and s < obj[1]:
                ptrs.append((s, p))
        ptrs.sort(reverse=True)
        return ptrs

    def __sort_pointers_by_objs(self, obj_mem, symbolic_pointers):
        objects = {}
        unresolved = []
        for (s,p) in symbolic_pointers:
            found = False
            for o in obj_mem:
                if s >= o[0] and s < o[1]:
                    if o[0] not in objects:
                        objects[o[0]] = [(s,p)]
                    else:
                        objects[o[0]].append((s,p))
                    found = True
                    break

            if not found:
                unresolved.append((s,p))

        return objects, unresolved
