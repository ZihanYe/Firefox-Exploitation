# Example --- CVE-2018-5100

At the point when the dangling pointer is accessible right after occurrence of free, we have the following code:

```
(gdb) x /16i $rip
=> 0x7f68fbb72820 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+46>:
    mov    -0x20(%rbp),%rax
   0x7f68fbb72824 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+50>:
    mov    %rax,%rdi
   0x7f68fbb72827 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+53>:
    callq  0x7f68fb647d86 <mozilla::dom::Element::GetPrimaryFrame() const>
   0x7f68fbb7282c <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+58>:
    mov    %rax,-0x10(%rbp)
   0x7f68fbb72830 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+62>:
    cmpq   $0x0,-0x10(%rbp)
   0x7f68fbb72835 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+67>:
    jne    0x7f68fbb72841 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+79>
   0x7f68fbb72837 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+69>:
    mov    $0x0,%eax
   0x7f68fbb7283c <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+74>:
    jmpq   0x7f68fbb728e3 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+241>
   0x7f68fbb72841 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+79>:
    mov    -0x20(%rbp),%rax
   0x7f68fbb72845 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+83>:
    mov    %rax,%rdi
   0x7f68fbb72848 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+86>:
    callq  0x7f68fb3400f8 <nsINode::GetParent() const>
   0x7f68fbb7284d <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+91>:
    mov    %rax,%rdi
   0x7f68fbb72850 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+94>:
    callq  0x7f68fb647ab6 <nsIContent::GetPrimaryFrame() const>
```

then symbolic execution kicks in, with initial state:

```
-----start dump state-----
**registers**
rax: <BV64 0x0>  r8: <BV64 0x8>
rbx: <BV64 0x558429551e60>  r9: <BV64 0x8>
rcx: <BV64 0x0>  r10: <BV64 0x5584295c37a0>
rdx: <BV64 0x0>  r11: <BV64 0x2>
rsi: <BV64 0x1>  r12: <BV64 0x7ffdf0058750>
rdi: <BV64 0x558429551e60>  r13: <BV64 0x558426a572b0>
rsp: <BV64 0x7ffdf0057d20>  r14: <BV64 0x7f68fa169ac4>
rbp: <BV64 0x7ffdf0057d40>  r15: <BV64 0x7ffdf005a1f0>
gs: <BV64 0x70756b00000000>
**instructions**
IRSB {
   t0:Ity_I64 t1:Ity_I64 t2:Ity_I64 t3:Ity_I64 t4:Ity_I64 t5:Ity_I64 t6:Ity_I64 t7:Ity_I64 t8:Ity_I64 t9:Ity_I64 t10:Ity_I64

   00 | ------ IMark(0x7f68fbb72820, 4, 0) ------
   01 | t4 = GET:I64(rbp)
   02 | t3 = Add64(t4,0xffffffffffffffe0)
   03 | t5 = LDle:I64(t3)
   04 | PUT(rax) = t5
   05 | ------ IMark(0x7f68fbb72824, 3, 0) ------
   06 | PUT(rdi) = t5
   07 | PUT(rip) = 0x00007f68fbb72827
   08 | ------ IMark(0x7f68fbb72827, 5, 0) ------
   09 | t8 = GET:I64(rsp)
   10 | t7 = Sub64(t8,0x0000000000000008)
   11 | PUT(rsp) = t7
   12 | STle(t7) = 0x00007f68fbb7282c
   13 | t9 = Sub64(t7,0x0000000000000080)
   14 | ====== AbiHint(0xt9, 128, 0x00007f68fb647d86) ======
   NEXT: PUT(rip) = 0x00007f68fb647d86; Ijk_Call
}
0x7f68fbb72820:	mov	rax, qword ptr [rbp - 0x20]
0x7f68fbb72824:	mov	rdi, rax
0x7f68fbb72827:	call	0x7f68fb647d86
-----end dump state-----
```

After some steps, it reaches:
```
====================================================================================================MEMWRITE
write  <BV64 uaf_obj79_79_8 .. uaf_obj78_78_8 .. uaf_obj77_77_8 .. uaf_obj76_76_8 .. uaf_obj75_75_8 .. uaf_obj74_74_8 .. uaf_obj73_73_8 .. uaf_obj72_72_8>  to  <BV64 0x7ffdf0057d30>  of size  <BV64 0x8> Write target type: <class 'claripy.ast.bv.BV'>
uninit: None symbolic: False
[+] add to taint memory region
```

Investigate what is happening here using history logged with this state:
```
{'access': 'taint_mem',
  'inst': 140088876410924,
  'write_to': 140728630345008,
  'write_size': <BV64 0x8>,
  'value': <BV64 uaf_obj79_79_8 .. uaf_obj78_78_8 .. uaf_obj77_77_8 .. uaf_obj76_76_8 .. uaf_obj75_75_8 .. uaf_obj74_74_8 .. uaf_obj73_73_8 .. uaf_obj72_72_8>,
  'constraints': [<Bool ((0#56 .. (0 .. (if uaf_obj28_28_8[1:1] == 0 then 0 else 1))) & 0xff) != 0x0>]}
 ```

At address ```140088876410924 (0x7f68fbb7282c)```, it writes some value related to the freed object to memory at ```0x7ffdf0057d30```

Print the code at this address using GDB:

```
(gdb) x /16i 0x7f68fbb7282c
   0x7f68fbb7282c <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+58>:
    mov    %rax,-0x10(%rbp)
   0x7f68fbb72830 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+62>:
    cmpq   $0x0,-0x10(%rbp)
   0x7f68fbb72835 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+67>:
    jne    0x7f68fbb72841 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+79>
   0x7f68fbb72837 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+69>:
    mov    $0x0,%eax
   0x7f68fbb7283c <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+74>:
    jmpq   0x7f68fbb728e3 <nsIDocument::IsPotentiallyScrollable(mozilla::dom::HTMLBodyElement*)+241>

...
```

We can compare the execution of the actual program against the symbolic one inside GDB by setting watchpoint on ```0x7ffdf0057d30``` and GDB shows it is changed:
```
Thread 1 "firefox" hit Hardware watchpoint 5: *0x7ffdf0057d30

Old value = -268072624
New value = 0
nsIDocument::IsPotentiallyScrollable (this=0x558429551e60, aBody=0x55842953a790)
    at /home/ug16zy2/firefox-56.0/dom/base/nsDocument.cpp:10569
10569	  if (!bodyFrame) {
(gdb) info registers
rax            0x0	0
rbx            0x558429551e60	94026117488224
rcx            0x1	1
rdx            0x20008	131080
rsi            0x800	2048
rdi            0x55842953a798	94026117392280
rbp            0x7ffdf0057d40	0x7ffdf0057d40
```

Value of ```rbp``` is ```0x7ffdf0057d40``` and ```rax``` is 0, which means in actual program, it is writing 0 to ```0x7ffdf0057d30```.

Following the write, it executes ```cmpq   $0x0,-0x10(%rbp)```, which corresponds to

```
bool
nsIDocument::IsPotentiallyScrollable(HTMLBodyElement* aBody)
{
  // We rely on correct frame information here, so need to flush frames.
  FlushPendingNotifications(FlushType::Frames);

  // An element is potentially scrollable if all of the following conditions are
  // true:

  // The element has an associated CSS layout box.
  nsIFrame* bodyFrame = aBody->GetPrimaryFrame();
  if (!bodyFrame) {
    return false;
  }
```

in C++. Since```bodyFrame``` (in ```-0x10(%rbp)```) is null(0), it returns false.

However, inside symbolic execution, since the log tells us the value written to ```-0x10(%rbp)``` is actually comes from the freed object, and moreover it should comes from 8 bytes starting from offset 72 inside the freed object. Then if we reallocate something new onto the freed region, we could have avoided the return here.

Symbolic execution explores the possibility that the value written were not 0 and continues exploring. It finds many other writes symbolic value to somewhere else. For example:
```
{'access': 'taint_mem',
  'inst': 140088870992574,
  'write_to': 140728630344968,
  'write_size': <BV64 0x8>,
  'value': <BV64 uaf_obj47_47_8 .. uaf_obj46_46_8 .. uaf_obj45_45_8 .. uaf_obj44_44_8 .. uaf_obj43_43_8 .. uaf_obj42_42_8 .. uaf_obj41_41_8 .. uaf_obj40_40_8>,
  'constraints': [<Bool ((0#56 .. (0 .. (if uaf_obj28_28_8[1:1] == 0 then 0 else 1))) & 0xff) != 0x0>,
   <Bool (uaf_obj79_79_8 .. uaf_obj78_78_8 .. uaf_obj77_77_8 .. uaf_obj76_76_8 .. uaf_obj75_75_8 .. uaf_obj74_74_8 .. uaf_obj73_73_8 .. uaf_obj72_72_8) != 0x0>,
   <Bool (0#56 .. (0 .. (if uaf_obj28_28_8[2:2] == 0 then 0 else 1))) != 0x0>]},
 {'access': 'read_taint',
  'inst': 140088870992578,
  'read_from': <BV64 0x7ffdf0057d08>,
  'read_size': 8,
  'value': <BV64 uaf_obj47_47_8 .. uaf_obj46_46_8 .. uaf_obj45_45_8 .. uaf_obj44_44_8 .. uaf_obj43_43_8 .. uaf_obj42_42_8 .. uaf_obj41_41_8 .. uaf_obj40_40_8>,
  'constraints': [<Bool ((0#56 .. (0 .. (if uaf_obj28_28_8[1:1] == 0 then 0 else 1))) & 0xff) != 0x0>,
   <Bool (uaf_obj79_79_8 .. uaf_obj78_78_8 .. uaf_obj77_77_8 .. uaf_obj76_76_8 .. uaf_obj75_75_8 .. uaf_obj74_74_8 .. uaf_obj73_73_8 .. uaf_obj72_72_8) != 0x0>,
   <Bool (0#56 .. (0 .. (if uaf_obj28_28_8[2:2] == 0 then 0 else 1))) != 0x0>]},
 ...
```

Note that it have added the constraint:
```
<Bool (uaf_obj79_79_8 .. uaf_obj78_78_8 .. uaf_obj77_77_8 .. uaf_obj76_76_8 .. uaf_obj75_75_8 .. uaf_obj74_74_8 .. uaf_obj73_73_8 .. uaf_obj72_72_8) != 0x0>
```
that is, the value written to ```0x7ffdf0057d30``` has to be non-zero to reach other read/write.


Of course, we are more interested in control hijack and write primitive. So symbolic execution is continued until all active states have reached the end (i.e. the point where the dangling pointer is no longer accessible).

However, for this particular vulnerability, no control hijack nor write primitive were found before reaching the end. That means, although we had writes with symbolic value, we didn't find any write with symbolic value to symbolic address, nor jump to symbolic address. I think this could provide evidence that this vulnerability is unlikely to be exploitable.
