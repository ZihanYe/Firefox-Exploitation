import angr
import logging
log = logging.getLogger("symbolic")

class ControlledMap(angr.SimStatePlugin):
    def __init__(self, num_objs = 0, obj_list=[], var_list = [], point_to = [], pointed_by=[], pointers = []):
        super(StateContraints, self).__init__()
        self.num_objs = num_objs
        # [[lower, upper]]
        self.obj_list = obj_list
        self.point_to = point_to
        self.pointed_by = pointed_by
        self.pointers = pointers

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        return ControlledMap(self.num_objs, self.obj_list, self.point_to, self.pointed_by, self.pointers)

    def add_obj(self. start, end):
        self.obj_list.append([start, end])
        self.num_objs += 1
        return self.num_objs-1

    def get_obj_contain(self, addr):
        try:
            for i in range(self.num_objs):
                obj = self.obj_list[i]
                if self.state.solver.eval(obj[0] <= addr) and self.state.solver.eval(obj[1] > addr):
                    return i
        except:
            log.error( "[-] EXCEPTION during checking "+ str(addr)+ " is inside a controlled object or not")
        return None

    # when read from address in controlled memory for the first time, add a variable of that content
    # condition: addr is NOT UNCONSTRAINED
    def add_variable(self, obj, addr, len):
        var = memory.load(addr ,size=len,inspect=False)
        if not isinstance(var,int) and var.symbolic:
            for v in self.var_list[obj]:
                if self.state.solver.eval(v[0] == addr):
                    return
                self.var_list[obj].append([addr, var])

    def get_obj_containing_variable(self, var):
        try:
            for i in range(self.num_objs):
                vars = self.var_list[i]
                for v in vars:
                    if v[1] is var:
                        return i
        except:
            log.error( "[-] EXCEPTION in get_obj_containing_variable")

    # when dereference and concretization, add point-to relationship
    def add_point_to(self, obj1, obj2, addr):
        self.point_to[obj1].append([addr, obj2])
        self.pointed_by[obj2].append(obj1)
