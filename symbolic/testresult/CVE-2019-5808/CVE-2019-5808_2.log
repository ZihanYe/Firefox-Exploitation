-----start dump executor-----
Step:  1050
State stats:
****************************************************************************************************
Type                   Count
-------------------  -------
write primitive (W)        1
control_hijack (C)         0
active (A)               100
unconstrained (U)          0
errored (E)              348
found                      0
avoided                    0
paths to write primitive:  82
paths to control hijack:  0
first primitive after:  71
total paths:  1187
****************************************************************************************************
Some errored states: 
<State errored with "No bytes in memory for block starting at 0x7ffcb6f2142e.">
<State errored with "No bytes in memory for block starting at 0x7ffcb6f2142e.">
<State errored with "No bytes in memory for block starting at 0x7ffcb6f2142e.">
<State errored with "No bytes in memory for block starting at 0x7ffcb6f2142e.">
<State errored with "No bytes in memory for block starting at 0x7ffcb6f2142e.">
****************************************************************************************************
Some write primitives: 
Write primitive  0
****************************************************************************************************
-----start dump state-----
**registers**
rax: <BV64 0x90c4f08fda55f500>  r8: <BV64 0x5633a49170d8>
rbx: <BV64 0x30cbac079560>  r9: <BV64 0x36f43ef61bc0>
rcx: <BV64 0x30cbac078b40>  r10: <BV64 0x0>
rdx: <BV64 0x1>  r11: <BV64 0x8feb320d>
rsi: <BV64 0x30cbac079ec0>  r12: <BV64 uaf_obj47_48_8 .. uaf_obj46_47_8 .. uaf_obj45_46_8 .. uaf_obj44_45_8 .. uaf_obj43_44_8 .. uaf_obj42_43_8 .. uaf_obj41_42_8 .. uaf_obj40_41_8>
rdi: <BV64 uaf_obj47_48_8 .. uaf_obj46_47_8 .. uaf_obj45_46_8 .. uaf_obj44_45_8 .. uaf_obj43_44_8 .. uaf_obj42_43_8 .. uaf_obj41_42_8 .. uaf_obj40_41_8>  r13: <BV64 0x3b289001>
rsp: <BV64 0x7ffcefc7c010>  r14: <BV64 0x30cbac079ec0>
rbp: <BV64 0x7ffcefc7c150>  r15: <BV64 0x30cbac079ec0>
gs: <BV64 reg_gs_0_64{UNINITIALIZED}>
**instructions**
IRSB {
   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I64 t4:Ity_I64 t5:Ity_I64 t6:Ity_I1 t7:Ity_I64 t8:Ity_I64 t9:Ity_I64 t10:Ity_I64 t11:Ity_I64 t12:Ity_I64

   00 | ------ IMark(0x5633a7559759, 3, 0) ------
   01 | t3 = GET:I64(rdi)
   02 | t2 = LDle:I32(t3)
   03 | t1 = 0x00000001
   04 | t0 = Add32(t2,t1)
   05 | STle(t3) = t0
   06 | PUT(cc_op) = 0x0000000000000003
   07 | t4 = 32Uto64(t2)
   08 | PUT(cc_dep1) = t4
   09 | t5 = 32Uto64(t1)
   10 | PUT(cc_dep2) = t5
   11 | PUT(rip) = 0x00005633a755975c
   12 | ------ IMark(0x5633a755975c, 2, 0) ------
   13 | t7 = GET:I64(cc_op)
   14 | t8 = GET:I64(cc_dep1)
   15 | t9 = GET:I64(cc_dep2)
   16 | t10 = GET:I64(cc_ndep)
   17 | t11 = amd64g_calculate_condition(0x0000000000000004,t7,t8,t9,t10):Ity_I64
   18 | t6 = 64to1(t11)
   19 | if (t6) { PUT(rip) = 0x5633a755975e; Ijk_Boring }
   20 | PUT(rip) = 0x00005633a7559788
   21 | t12 = GET:I64(rip)
   NEXT: PUT(rip) = t12; Ijk_Boring
}
0x5633a7559759:	add	dword ptr [rdi], 1
0x5633a755975c:	jne	0x5633a7559788
-----end dump state-----
****************************************************************************************************
object:                  OBJ_0
(possible) base address  0x30cbac079ec0
maximum memory range     [  0x30cbac079ec0  ,  0x30cbac079f70  ]
 
contains pointers:      
offset    points to    offset in target
--------  -----------  ------------------
0x28      OBJ_1        0x0
 
This is the UAF object, all bytes of it are symbolic variables
Object size:  0xb0
contains variables:     
 <BV8 uaf_obj0_1_8>  ...  <BV8 uaf_obj175_176_8>

****************************************************************************************************
object:                  OBJ_1
(possible) base address  0xc0000200
maximum memory range     [  0xc0000000  ,  0xc0000700  ]
 
contains pointers:      
   No pointers     
 
contains variables:     
variable                                   offsets
-----------------------------------------  ---------
<BV32 mem_c0000200_178_32{UNINITIALIZED}>  0x0

****************************************************************************************************
Symbolic pointers that we are not sure which object it belongs to:
address    points to
---------  -----------
--------------------------------------------------
****************************************************************************************************
Variables that we are not sure which object it belongs to:
variable                                  address
----------------------------------------  ---------
<BV64 reg_gs_0_64{UNINITIALIZED}>
<BV64 reg_cc_ndep_177_64{UNINITIALIZED}>

****************************************************************************************************
This is a write primitive
You have full control of what and where to write
It happens at:  94779850725209
Write  <BV64 0x4>  bytes to  <BV64 uaf_obj47_48_8 .. uaf_obj46_47_8 .. uaf_obj45_46_8 .. uaf_obj44_45_8 .. uaf_obj43_44_8 .. uaf_obj42_43_8 .. uaf_obj41_42_8 .. uaf_obj40_41_8>
with expression : <BV32 mem_c0000200_178_32{UNINITIALIZED} + 0x1>
Call Stack:
----------------------------------------------------------------------------------------------------
At  0x5633a7559740
0x5633a7559740:	push	rbp
0x5633a7559741:	mov	rbp, rsp
0x5633a7559744:	push	rbx
0x5633a7559745:	sub	rsp, 0x138
0x5633a755974c:	mov	rax, qword ptr fs:[0x28]
0x5633a7559755:	mov	qword ptr [rbp - 0x10], rax
0x5633a7559759:	add	dword ptr [rdi], 1
0x5633a755975c:	jne	0x5633a7559788
----------------------------------------------------------------------------------------------------
At  0x5633a8abb3e0
0x5633a8abb3e0:	push	rbp
0x5633a8abb3e1:	mov	rbp, rsp
0x5633a8abb3e4:	push	r15
0x5633a8abb3e6:	push	r14
0x5633a8abb3e8:	push	r12
0x5633a8abb3ea:	push	rbx
0x5633a8abb3eb:	mov	r14, rsi
0x5633a8abb3ee:	mov	rbx, rdi
0x5633a8abb3f1:	mov	r12, qword ptr [rsi + 0x28]
0x5633a8abb3f5:	test	r12, r12
0x5633a8abb3f8:	je	0x5633a8abb402
----------------------------------------------------------------------------------------------------
At  0x5633a9827fb0
0x5633a9827fb0:	push	rbp
0x5633a9827fb1:	mov	rbp, rsp
0x5633a9827fb4:	push	r15
0x5633a9827fb6:	push	r14
0x5633a9827fb8:	push	r13
0x5633a9827fba:	push	r12
0x5633a9827fbc:	push	rbx
0x5633a9827fbd:	push	rax
0x5633a9827fbe:	mov	r14d, edx
0x5633a9827fc1:	mov	r15, rsi
0x5633a9827fc4:	mov	rbx, rdi
0x5633a9827fc7:	mov	rax, qword ptr [rdi + 0x30]
0x5633a9827fcb:	mov	rax, qword ptr [rax + 8]
0x5633a9827fcf:	mov	r13d, dword ptr [rax + 0x78]
0x5633a9827fd3:	call	0x5633a8abb3e0
----------------------------------------------------------------------------------------------------
****************************************************************************************************
constraints:             
0  <Bool uaf_obj40_41_8 == 0>
1  <Bool uaf_obj41_42_8 == 2>
2  <Bool uaf_obj42_43_8 == 0>
3  <Bool uaf_obj43_44_8 == 192>
4  <Bool uaf_obj44_45_8 == 0>
5  <Bool uaf_obj45_46_8 == 0>
6  <Bool uaf_obj46_47_8 == 0>
7  <Bool uaf_obj47_48_8 == 0>

****************************************************************************************************
Variables used as return values of symbolic calls: 

****************************************************************************************************
We've logged: 
         taint_mem:          write with controlled value 
         read_taint:         read from tainted memory 
         call:               call with controlled function address 
         jump:               call with controlled destination address 
         write_ret_val:      write return value to memory 
         deref_ret_val_w:    dereference returned pointer for write 
         deref_ret_val_r:    dereference returned pointer for read 
****************************************************************************************************
Execution history:        

****************************************************************************************************
Some control hijacks: 
-----end dump executor-----
