import angr
import logging
import time

log = logging.getLogger("symbolic")

class Solution:
    def find_solution(self, state, allow_multiple_objects = True):
        if not state.has_plugin("abstractHeap"):
            log.error("[-] unable to generate a solution for a state without abstract heap")
            return None
        if not state.solver.satisfiable():
            return None
        absHeap = state.abstractHeap
        final_obj_region = [absHeap.object_region[0]]
        final_obj_addrs = [absHeap.object_addrs[0]]
        final_obj_vars = [absHeap.object_vars[0]]
        final_constraints = []
        final_obj_pointers = [{} for i in absHeap.n]

        obj_map = {}
        obj_map[0] = (0,0)
        uaf_obj_bytes, first_byte, last_byte = self.__get_constrainted_bytes(absHeap, 0)

        for i in range(1, absHeap.n):
            vs, min_off, max_off = self.__get_constrainted_bytes(absHeap, i)
            # need space [min_off, max_off)
            # check pointer positions
            match_offset = max(0, min_off*(-1))
            ok = True
            while match_offset + max_off <= self.uaf_object_size:
                ok = True
                for offset, size in vs.items():
                    actual_offset = offset + match_offset
                    for b,s in uaf_obj_bytes.items():
                        if (actual_offset <= b and actual_offset+size >= b) or (b<=actual_offset and b+s >= actual_offset):
                            ok = False
                            break
                if not ok:
                    match_offset += 8
                else:
                    break
            if not ok and not allow_multiple_objects:
                return None # unsatisfiable
            elif not ok:
                # keep its own object
                final_obj_region.append(absHeap.object_region[i])
                final_obj_addrs.append(absHeap.object_addrs[i])
                obj_map[i] = (i,0)
            else:
                # merge object i into object 0
                obj_map[i] = (0, match_offset)
                final_obj_region.append(absHeap.object_region[0])
                final_obj_addrs.append(absHeap.object_addrs[0]+match_offset)
                for offset, size in vs.items():
                    uaf_obj_bytes[offset+match_offset] = size

        # convert variables
        replace_dict = {}
        for i in range(1,absHeap.n):
            if obj_map[i][0] == i:
                final_obj_vars.append(absHeap.object_vars[i])
                for off, p in absHeap.object_pointers.items():
                    final_obj_pointers[i][offset] = obj_map[p][0]
            else:
                final_obj_vars.append(set())
                match_offset = obj_map[i][1]
                for v in absHeap.object_vars[i]:
                    index, offset = absHeap.get_obj_offset_for_var(v)
                    assert(index == i)
                    v_to_replace = absHeap.get_object_variable(0, offset+match_offset, v.size()//8)
                    final_obj_vars[0].add(v_to_replace)
                    replace_dict[v.cache_key] = v_to_replace
                    for off, p in absHeap.object_pointers.items():
                        final_obj_pointers[0][off+match_offset] = obj_map[p][0]

        # replace constraints
        for c in state.solver.constraints:
            # not pointer constraint
            if c.op == '__eq__':
                if (isinstance(c.args[0],int) or c.args[0].concrete) and state.record.check_inside_obj(c.args[0]):
                    continue
                elif (isinstance(c.args[1],int) or c.args[1].concrete) and state.record.check_inside_obj(c.args[1]):
                    continue
            final_constraints.append(c.replace_dict(replace_dict))

        # return
        solution = {
            'object_regions' : final_obj_region,
            'object_addrs': final_obj_addrs,
            'object_pointers': final_obj_pointers,
            'object_vars': final_obj_vars,
            'constraints': final_constraints
        }
        return solution

    def __get_constrainted_bytes(self, absHeap, i):
        vs = {}
        max_off = 0
        min_off = 0
        for offset, p in absHeap.object_pointers[i].items():
            vs[offset] = 8
            if offset+8 > max_off:
                max_off = offset+8
            if offset < min_off:
                min_off = offset
        for var in absHeap.object_vars[i]:
            index, offset = absHeap.get_obj_offset_for_var(var)
            assert(index == i)
            vs[offset] = var.size()//8
            if offset+var.size()//8 > max_off:
                max_off = offset+var.size()//8
            if offset < min_off:
                min_off = offset
        return vs, min_off, max_off
