import angr

CRITICAL_HISTORY = ['call', 'jump'] #, 'deref_ret_val_r', 'write_ret_val', 'deref_ret_val_w']

class StateAnalyse:
    def __init__(self, state, uaf_object_base, uaf_object_size):
        self.state = state
        self.uaf_object_base = uaf_object_base
        self.uaf_object_size = uaf_object_size

        self.obj_mem = self.state.record.obj_mem
        self.n = len(self.obj_mem)
        self.name = ["OBJ_"+ str(i) for i in range(len(self.obj_mem))]

        self.symbolic_pointers = self.state.record.symbolic_pointer
        self.vars = list(self.state.solver.all_variables)

        # result to be analysed
        self.matrix = []
        self.symbolic_return_point = []
        self.unresolved_ptrs = []
        self.vars_in_objs = []
        self.unresolved_vars = []
        self.obj_start = []

        self.constraints = self.state.solver.constraints.copy()
        self.constraints.sort(key=lambda c: str(c))
        self.analyse()

    def analyse(self):
        # objects
        m, u = self.__get_point_matrix()
        self.matrix = m
        self.unresolved_ptrs = u

        # variables
        l, uv = self.__variable_map()
        self.vars_in_objs = l
        self.unresolved_vars = uv

        # other info
        for i in range(len(self.obj_mem)):
            self.obj_start.append(self.__possible_start(i))
            if self.obj_mem[i][0] == self.uaf_object_base:
                self.name[i] = "UAF_OBJ"

        self.obj_layout = {}
        for i in range(self.n):
            for j in range(self.n):
                if len(self.matrix[i][j]) > 0:
                    if i in self.obj_layout:
                        self.obj_layout[i].append(j)
                    else:
                        self.obj_layout[i] = [j]

        self.critical_history = list(filter(lambda h: h['access'] in CRITICAL_HISTORY, self.state.record.history))


    def has_same_layout(self, aStateInfo):
        return self.obj_layout == aStateInfo.obj_layout

    def has_same_critical_history(self, aStateInfo):
        if len(self.critical_history) != len(aStateInfo.critical_history):
            return False

        for i in range(len(self.critical_history)):
            h1 = self.critical_history[i]
            h2 = aStateInfo.critical_history[i]
            for key in ['access', 'call', 'jump_to']:
                if not key in h1 and not key in h2:
                    continue
                if key in h1 and key in h2 and h1[key] == h2[key]:
                    continue
                return False
        return True

    def has_same_constraints(self, aStateInfo):
        if len(self.state.constraints) != len(aStateInfo.state.constraints):
            return False
        for i in range(len(self.state.constraints)):
            if not (self.state.constraints[i] is aStateInfo.state.constraints):
                return False
        return True


    def __inside(self, addr):
        for i in range(len(self.obj_mem)):
            if addr >= self.obj_mem[i][0] and addr < self.obj_mem[i][1]:
                return i
        return None


    def __get_point_matrix(self):
        n = len(self.obj_mem)
        matrix = [[[] for i in range(n)] for j in range(n)]
        unresolved = []
        for (s,p) in self.symbolic_pointers:
            pointed_by = None
            for i in range(n):
                if s >= self.obj_mem[i][0] and s < self.obj_mem[i][1]:
                    pointed_by = i
                    break

            point_to = None
            for i in range(n):
                if p >= self.obj_mem[i][0] and p < self.obj_mem[i][1]:
                    point_to = i
                    break

            if pointed_by is not None and point_to is not None:
                matrix[pointed_by][point_to].append((s,p))
            else:
                unresolved.append((s,p))

        for (d, ins, var) in self.state.record.depth_limited_var:
            idx = self.state.record.check_inside_obj_index(var)
            if idx is not None:
                self.symbolic_return_point.append((var, idx))

        return matrix, unresolved

    def __possible_start(self, index):
        if self.obj_mem[index][0] == self.uaf_object_base:
            # it is the uaf object
            return self.obj_mem[index][0]

        start = self.obj_mem[index][1]
        found = False
        for i in range(len(self.obj_mem)):
            for (s,p) in self.matrix[i][index]:
                if p < start:
                    # possible base address
                    start = p
                    found = True
        for (v, a) in self.vars_in_objs[index]:
            # a = min(addrs)
            if a < start:
                start = a
                found = True

        for (v, idx) in self.symbolic_return_point:
            if idx == index and self.state.solver.eval(v < start):
                start = v.long
                found = True
        if not found:
            start = self.obj_mem[index][0]
        return start

    def __variable_map(self):
        vars_in_objs= [[] for i in range(len(self.obj_mem))]
        unresolved = []
        for v in self.vars:
            # get addrs
            # addrs = list(self.state.memory.addrs_for_hash(hash(v)))
            addr = self.state.record.get_addr_for_var(v)
            if addr is not None:
                index = self.state.record.check_inside_obj_index(addr)
                if index is not None:
                    vars_in_objs[index].append((v, addr))
                else:
                    unresolved.append((v, addr))
            else:
                unresolved.append((v, addr))
        return vars_in_objs, unresolved
