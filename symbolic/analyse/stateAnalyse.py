import angr

class StateAnalyse:
    def __init__(self, state, uaf_object_base, uaf_object_size):
        self.state = state
        self.uaf_object_base = uaf_object_base
        self.uaf_object_size = uaf_object_size

        self.obj_mem = self.state.record.obj_mem
        self.name = ["OBJ_"+ str(i) for i in range(len(self.obj_mem))]

        self.symbolic_pointers = self.state.record.symbolic_pointer
        self.vars = list(self.state.solver.all_variables)

        # result to be analysed
        self.matrix = []
        self.unresolved_ptrs = []
        self.unresolved_vars = []
        self.obj_start = []

        self.analyse()

    def analyse(self):
        # objects
        m, u = self.__get_point_matrix()
        self.matrix = m
        self.unresolved_ptrs = u

        # variables
        l, uv = self.__variable_map()
        self.vars_in_objs = l
        self.unresolved_vars = uv

        # other info
        for i in range(len(self.obj_mem)):
            self.obj_start.append(self.__possible_start(i))
            if self.obj_mem[i][0] == self.uaf_object_base:
                self.name[i] = "UAF_OBJ"


    def __inside(self, addr):
        for i in range(len(self.obj_mem)):
            if addr >= self.obj_mem[i][0] and addr < self.obj_mem[i][1]:
                return i
        return None


    def __get_point_matrix(self):
        n = len(self.obj_mem)
        matrix = [[[] for i in range(n)] for j in range(n)]
        unresolved = []
        for (s,p) in self.symbolic_pointers:
            pointed_by = None
            for i in range(n):
                if s >= self.obj_mem[i][0] and s < self.obj_mem[i][1]:
                    pointed_by = i
                    break

            point_to = None
            for i in range(n):
                if p >= self.obj_mem[i][0] and p < self.obj_mem[i][1]:
                    point_to = i
                    break

            if pointed_by is not None and point_to is not None:
                matrix[pointed_by][point_to].append((s,p))
            else:
                unresolved.append((s,p))

        return matrix, unresolved

    def __possible_start(self, index):
        if self.obj_mem[index][0] == self.uaf_object_base:
            # it is the uaf object
            return self.obj_mem[index][0]

        start = self.obj_mem[index][1]
        found = False
        for i in range(len(self.obj_mem)):
            for (s,p) in self.matrix[i][index]:
                if p < start:
                    # possible base address
                    start = p
                    found = True
            for (v, addrs) in self.vars_in_objs[i]:
                a = min(addrs)
                if a < start:
                    start = a
                    found = True
        if not found:
            start = self.obj_mem[index][0]
        return start

    def __variable_map(self):
        vars_in_objs= [[] for i in range(len(self.obj_mem))]
        unresolved = []
        for v in self.vars:
            # get addrs
            addrs = list(self.state.memory.addrs_for_hash(hash(v)))
            if len(addrs) > 0:
                addr = min(addrs)
                index = self.__inside(addr)
                if index is not None:
                    vars_in_objs[index].append((v, addrs))
                else:
                    unresolved.append((v, addrs))
            else:
                unresolved.append((v, addrs))
        return vars_in_objs, unresolved
