import angr
import time
import traceback
import logging
import dfsSimgr
import restrictedExplore
import time
from analyse.stateAnalyse import StateAnalyse

log = logging.getLogger("symbolic")

class DepthExplorer(restrictedExplore.RestrictedExplore):
    def __init__(self, proj, initial_state, goal_state, depth_limit, uaf_object_base, uaf_object_size, step_limit=10000):
        self.initial_state = initial_state
        self.depth_add_instrumentation()
        self.goal_state = goal_state
        self.proj = proj
        self.simgr = proj.factory.simgr(initial_state)
        plain_constraints, depth_constraints = self.split_constraints(goal_state)
        self.plain_constraints = plain_constraints
        self.depth_constraints = depth_constraints
        self.depth_limited_var = goal_state.record.depth_limited_var
        self.depth_limit = depth_limit
        self.step_limit = step_limit

        analyse = StateAnalyse(self.goal_state, uaf_object_base, uaf_object_size)
        self.matrix = analyse.matrix
        self.unresolved_ptrs = analyse.unresolved_ptrs
        self.symbolic_return_point = analyse.symbolic_return_point
        self.vars_in_objs = analyse.vars_in_objs
        self.unresolved_vars = analyse.unresolved_vars
        self.obj_start = analyse.obj_start

        self.analyseReturns()


    def analyseReturns(self):
        self.return_constraints = []
        for (d, instr, var) in self.depth_limited_var:
            obj_idx = self.goal_state.record.check_inside_obj_index(var)
            if obj_idx is not None: # returns a pointer
                # get replated object
                related = self.__get_related_objects(obj_idx)
                c = {
                    'type': 'pointer',
                    'point_to': obj_idx,
                    'related' : related,
                }
            else:
                # a value or unused
                c = {
                    'type': 'value',
                }
            self.return_constraints.append(c)

    def depth_explore(self):
        stop = False
        step = 0
        while not stop:
            to_explore = []
            for a in self.simgr.stashes['active']:
                replaced_var, ret_info = self.is_depth_limit_call(a)
                if replaced_var is not None:
                    # was replaced, now expend
                    # spawn a simgr
                    a.record.inside_dfs_explore = True
                    sub_simgr = dfsSimgr.DfsSimgr(self.proj, a, self.goal_state, replaced_var, ret_info)
                    after_ret = sub_simgr.explore()
                    if after_ret is not None:
                        # continue with state after return
                        after_ret.record.inside_dfs_explore = False
                        to_explore.append(after_ret)
                        log.info("[+] matched a depth limited part")
                        import IPython; IPython.embed()
                    else:
                        log.warning("[-] Unable to find a path satisfying the limited part")
                        self.simgr.stashes['unsat'].append(a)
                else:
                    to_explore.append(a)
            self.simgr.stashes['active'] = to_explore
            print("before stepping: ", len(self.simgr.stashes['active']), " active states")
            self.simgr.step(step_func = self.depth_step_func)
            print("after stepping: ", len(self.simgr.stashes['active']), " active states")
            step += 1
            stop = step > self.step_limit or len(self.simgr.stashes['active'])== 0 or len(self.simgr.stashes['found'])>0
        log.info("[+] Finished depth explore")
        import IPython; IPython.embed()


    def is_goal_state(self, state):
        return state.addr == self.goal_state.addr and state.record.primitive is not None

    def depth_step_func(self, lsm):
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='active', to_stash='found')

    def split_constraints(self, state):
        plain = []
        depth_limited = []
        for c in state.solver.constraints:
            found = False
            for l in c.leaf_asts():
                if "depth_limit" in str(l):
                    found = True
                    continue
            if found:
                depth_limited.append(c)
            else:
                plain.append(c)
        return plain, depth_limited

    def depth_add_instrumentation(self):
        self.initial_state.inspect.b('exit', when=angr.BP_BEFORE, action=self.track_successor)

    def is_depth_limit_call(self, state):
        depth = 0
        for c in state.callstack:
            depth += 1
        if depth == self.depth_limit+1 and state.history.jumpkind == 'Ijk_Call':
            if len(self.depth_limited_var)==0:
                print("mismatched call")
                import IPython; IPython.embed()
            (d, instr, var) = self.depth_limited_var[0]
            call_from = state.callstack.call_site_addr
            if call_from == instr:
                ret_info = self.return_constraints[0]
                self.depth_limited_var =  self.depth_limited_var[1:]
                self.return_constraints = self.return_constraints[1:]
                return var, ret_info
            else:
                print("missmathed call")
                import IPython; IPython.embed()
        return None, None

    def __get_related_objects(self, start_index, point_to_matrix):
        n = len(self.goal_state.record.obj_mem)
        to_add_list = [start_index]
        related = []
        related_objs = []
        while len(to_add_list) > 0:
            obj = to_add_list[0]
            related.append(obj)

            to_do_list = to_add_list[1:]
            for i in range(n):
                if len(self.matrix[obj][i]) > 0 and i not in related:
                    to_do_list.append(i)
        return related




'''
    def __get_variables_of_object(self, obj):
        vars = self.goal_state.solver.all_variables
        vars_of_obj = []
        for v in vars:
            addrs = list(self.goal_state.memory.addrs_for_hash(hash(v)))
            if len(addrs) > 0:
                addr = min(addrs)
                index = self.goal_state.record.check_inside_obj_index(addr)
                if index == obj:
                    vars_of_objs.append((v, addrs))
        return vars_of_obj

    def __variable_map(self):
        vars_in_objs= [[] for i in range(len(self.obj_mem))]
        unresolved = []
        for v in self.vars:
            # get addrs
            addrs = list(self.goal_state.memory.addrs_for_hash(hash(v)))
            if len(addrs) > 0:
                addr = min(addrs)
                index = self.check_inside_obj_index(addr)
                if index is not None:
                    vars_in_objs[index].append((v, addrs))
                else:
                    unresolved.append((v, addrs))
            else:
                unresolved.append((v, addrs))
        return vars_in_objs, unresolved

    def __get_point_matrix(self):
        n = len(self.goal_state.record.obj_mem)
        matrix = [[[] for i in range(n)] for j in range(n)]
        unresolved = []
        for (s,p) in self.goal_state.record.symbolic_pointers:
            pointed_by = None
            for i in range(n):
                if s >= self.goal_state.record.obj_mem[i][0] and s < self.goal_state.record.obj_mem[i][1]:
                    pointed_by = i
                    break

            point_to = None
            for i in range(n):
                if p >= self.goal_state.record.obj_mem[i][0] and p < self.goal_state.record.obj_mem[i][1]:
                    point_to = i
                    break

            if pointed_by is not None and point_to is not None:
                matrix[pointed_by][point_to].append((s,p))
            else:
                unresolved.append((s,p))

        symbolic_return_point = []
        for (d, ins, var) in self.goal_state.record.depth_limited_var:
            idx = self.goal_state.record.check_inside_obj_index(var)
            if idx is not None:
                symbolic_return_point.append((var, idx))

        return matrix, unresolved,symbolic_return_point
'''
