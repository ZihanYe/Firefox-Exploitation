import angr
import time
import traceback
import logging
import dfsSimgr
import restrictedExplore
import time

log = logging.getLogger("symbolic")

class DepthExplorer(restrictedExplore.RestrictedExplore):
    def __init__(self, proj, initial_state, goal_state, depth_limit, step_limit=10000):
        self.initial_state = initial_state
        self.depth_add_instrumentation()
        self.goal_state = goal_state
        self.proj = proj
        self.simgr = proj.factory.simgr(initial_state)
        plain_constraints, depth_constraints = self.split_constraints(goal_state)
        self.plain_constraints = plain_constraints
        self.depth_constraints = depth_constraints
        self.depth_limited_var = goal_state.record.depth_limited_var
        self.depth_limit = depth_limit
        self.step_limit = step_limit

    def depth_explore(self):
        stop = False
        step = 0
        while not stop:
            to_explore = []
            for a in self.simgr.stashes['active']:
                replaced_var = self.is_depth_limit_call(a)
                if replaced_var is not None:
                    # was replaced, now expend
                    # spawn a simgr
                    sub_simgr = dfsSimgr.DfsSimgr(state, self.goal_state, var)
                    after_ret = sub_simgr.explore()
                    if after_ret is not None:
                        # continue with state after return
                        to_explore.append(after_ret)
                        log.info("[+] matched a depth limited part")
                        import IPython; IPython.embed()
                    else:
                        log.warning("[-] Unable to find a path satisfying the limited part")
                        self.simgr.stashes['unsat'].append(a)
                else:
                    to_explore.append(a)
            self.simgr.step(step_func = self.depth_step_func)
            step += 1
            stop = step > self.step_limit or len(self.simgr.stashes['active'])== 0 or len(self.simgr.stashes['found'])>0
        log.info("[+] Finished depth explore")
        import IPython; IPython.embed()


    def is_goal_state(self, state):
        return state.addr == self.goal_state.addr and state.record.primitive is not None

    def depth_step_func(self, lsm):
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='active', to_stash='found')

    def split_constraints(self, state):
        plain = []
        depth_limited = []
        for c in state.solver.constraints:
            found = False
            for l in c.leaf_asts():
                if "depth_limit" in str(l):
                    found = True
                    continue
            if found:
                depth_limited.append(c)
            else:
                plain.append(c)
        return plain, depth_limited

    def depth_add_instrumentation(self):
        self.initial_state.inspect.b('exit', when=angr.BP_BEFORE, action=self.track_successor)

    def is_depth_limit_call(self, state):
        call_from = state.scratch.exit_ins_addr
        depth = 0
        for c in state.callstack:
            depth += 1
        if depth == self.depth_limit+1 and state.histry.jumpkind == 'Ijk_Call':
            (d, instr, var) = state.record.depth_limited_var[0]
            if call_from == instr:
                state.record.depth_limited_var =  state.record.depth_limited_var[1:]
                return var
            else:
                print("missmathed call")
                import IPython; IPython.embed()
        return None
