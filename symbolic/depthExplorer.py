import angr
import time
import traceback
import logging
import dfsSimgr
import restrictedExplore
import depthBpHandlers
import time
from analyse.stateAnalyse import StateAnalyse

log = logging.getLogger("symbolic")

class DepthExplorer(depthBpHandlers.DepthBpHandlers, restrictedExplore.RestrictedExplore):
    def __init__(self, proj, initial_state, goal_state, depth_limit, uaf_object_base, uaf_object_size, context_end, step_limit=10000):
        self.initial_state = initial_state
        self.depth_add_instrumentation(self.initial_state)
        self.add_instrumentation(self.initial_state)
        self.goal_state = goal_state
        self.ap = proj
        self.simgr = proj.factory.simgr(initial_state)
        plain_constraints, depth_constraints = self.split_constraints(goal_state)
        self.plain_constraints = plain_constraints
        self.depth_constraints = depth_constraints
        self.depth_limited_var = goal_state.record.depth_limited_var
        self.depth_limit = depth_limit
        self.step_limit = step_limit
        self.context_end = context_end

        analyse = StateAnalyse(self.goal_state, uaf_object_base, uaf_object_size)

        self.matrix = analyse.matrix
        self.unresolved_ptrs = analyse.unresolved_ptrs
        self.symbolic_return_point = analyse.symbolic_return_point
        self.vars_in_objs = analyse.vars_in_objs
        self.unresolved_vars = analyse.unresolved_vars
        self.obj_start = analyse.obj_start

        self.constrained_return_value = []
        self.analyseReturns()
        self.trainsform_constraints()
        self.constraints_by_var = {}
        for c in self.goal_state.solver.constraints:
            leaves = list(c.leaf_asts())
            for l in leaves:
                for v in self.goal_state.solver.all_variables:
                    if v is l:
                        if str(v) in self.constraints_by_var:
                            self.constraints_by_var[str(v)].append(c)
                        else:
                            self.constraints_by_var[str(v)] = [c]
                        break

        # primitives
        self.write_primitives = []
        self.control_hijacks = []

    def analyseReturns(self):
        self.return_constraints = []
        for (d, instr, var) in self.depth_limited_var:
            for c in self.goal_state.solver.constraints:
                found = False
                for l in c.leaf_asts():
                    if l is var:
                        self.constrained_return_value.append(var)
                        found = True
                        break;
                if found:
                    break;

            obj_idx = self.goal_state.record.check_inside_obj_index(var)
            if obj_idx is not None: # returns a pointer
                # get replated object
                c = {
                    'type': 'pointer',
                    'point_to': obj_idx,
                    # 'related' : related,
                }
            else:
                # a value or unused
                c = { 'type': 'value' }
            self.return_constraints.append(c)

    def trainsform_constraints(self):
        # transform constraints of goal_state to memory independent
        new_variables = []
        new_constraints = []
        for c in self.goal_state.solver.constraints:
            if c.op == '__eq__':
                if (isinstance(c.args[0],int) or c.args[0].concrete) and self.goal_state.record.check_inside_obj(c.args[0]):
                    continue
                if (isinstance(c.args[1],int) or c.args[1].concrete) and self.goal_state.record.check_inside_obj(c.args[1]):
                    continue
            new_constraints.append(c)

        vars_in_obj = [[] for o in self.goal_state.record.obj_mem]
        for v in self.goal_state.solver.all_variables:
            addr = None
            size = v.size()
            if str(v).find("uaf") != -1:
                new_variables.append(v)
                continue
            addr = self.goal_state.record.get_addr_for_var(v)
            if addr is not None:
                index = self.goal_state.record.check_inside_obj_index(addr)
                if index is not None:
                    # variable_set.append(v)
                    offset = addr - self.obj_start[index]
                    newv = self.goal_state.solver.BVS("obj_"+str(index)+"_"+str(offset)+"_"+str(size), size = size, explicit_name=True)
                    # replacing_dict[v] = newv
                    for i in range(len(new_constraints)):
                        new_constraints[i] = new_constraints[i].replace(v, newv)
                    new_variables.append(newv)
                    vars_in_obj[index].append(newv)
                else:
                    new_variables.append(v)
            else:
                new_variables.append(v)

        # replace
        self.goal_state.solver.reload_solver(constraints=new_constraints)
        self.goal_state.solver.all_variables = new_variables

    def depth_explore(self):
        stop = False
        step = 0
        while not stop:
            to_explore = []
            for a in self.simgr.stashes['active']:
                replaced_var, ret_info = self.is_depth_limit_call(a)
                if replaced_var is not None:
                    constrainted = False
                    for v in self.constrained_return_value:
                        if replaced_var is v:
                            constrainted = True; break
                    # in-depth exploration is not needed if return value is not constrainted
                    if constrainted:
                        # spawn a simgr
                        a.record.inside_dfs_explore = True
                        sub_simgr = dfsSimgr.DfsSimgr(self.ap, a, self.goal_state, replaced_var, ret_info, self.matrix, self.obj_start, self.constraints_by_var, self.context_end)
                        after_ret = sub_simgr.explore()
                        if after_ret is not None:
                            # continue with state after return
                            after_ret.record.inside_dfs_explore = False
                            to_explore.append(after_ret)
                            log.info("[+] matched a depth limited part")
                            import IPython; IPython.embed()
                        else:
                            log.warning("[-] Unable to find a path satisfying the limited part")
                            self.simgr.stashes['unsat'].append(a)
                    else:
                        to_explore.append(a)
                else:
                    to_explore.append(a)
            self.simgr.stashes['active'] = to_explore
            self.simgr.step(step_func = self.depth_step_func)
            step += 1
            stop = step > self.step_limit or len(self.simgr.stashes['active'])== 0 or len(self.write_primitives)>0 or len(self.control_hijacks)>0
        log.info("[+] Finished depth explore")
        return self.control_hijacks, self.write_primitives


    def is_goal_state(self, state):
        return state.addr == self.goal_state.addr and state.record.primitive is not None

    def depth_step_func(self, lsm):
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='active', to_stash='primitive')
        lsm.stash(filter_func=lambda s: s.addr == self.context_end, from_stash='active', to_stash='found')
        return lsm

    def split_constraints(self, state):
        plain = []
        depth_limited = []
        objs = []
        for c in state.solver.constraints:
            found = False
            for l in c.leaf_asts():
                if "depth_limit" in str(l):
                    found = True
                    continue
            if found:
                depth_limited.append(c)
            else:
                plain.append(c)
        return plain, depth_limited

    def depth_add_instrumentation(self, state):
        state.inspect.b('exit', when=angr.BP_BEFORE, action=self.track_successor)

    def add_instrumentation(self,state):
        state.inspect.b('mem_read', when=angr.BP_BEFORE, action=self.track_reads)
        state.inspect.b('mem_read', when=angr.BP_AFTER, action=self.track_after_reads)
        state.inspect.b('mem_write', when=angr.BP_BEFORE, action=self.track_writes)
        state.inspect.b('mem_write', when=angr.BP_AFTER, action=self.track_after_writes)
        state.inspect.b('call', when=angr.BP_BEFORE, action=self.track_call)
        state.inspect.b('exit',when=angr.BP_AFTER, action=self.track_after_jump)

    def is_depth_limit_call(self, state):
        depth = 0
        for c in state.callstack:
            depth += 1
        if depth == self.depth_limit+1 and state.history.jumpkind == 'Ijk_Call':
            if len(self.depth_limited_var)==0:
                log.error("[-] mismatched call")
                import IPython; IPython.embed()
            (d, instr, var) = self.depth_limited_var.pop(0)
            ret_info = self.return_constraints.pop(0)
            call_from = state.callstack.call_site_addr
            parent = state.history.parent.addr
            if call_from == instr:
                return var, ret_info
            else:
                log.error("[-] missmathed call")
                import IPython; IPython.embed()
        return None, None

    def __get_related_objects(self, start_index):
        n = len(self.goal_state.record.obj_mem)
        to_add_list = [start_index]
        related = []
        related_objs = []
        while len(to_add_list) > 0:
            obj = to_add_list[0]
            related.append(obj)

            to_do_list = to_add_list[1:]
            for i in range(n):
                if len(self.matrix[obj][i]) > 0 and i not in related:
                    to_do_list.append(i)
        return related
