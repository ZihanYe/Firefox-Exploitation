import angr
import time
import traceback
import logging
import dfsSimgr
import restrictedExplore
import depthBpHandlers
import time
from analyse.stateAnalyse import StateAnalyse

log = logging.getLogger("symbolic")

class DepthExplorer(depthBpHandlers.DepthBpHandlers, restrictedExplore.RestrictedExplore):
    def __init__(self, proj, initial_state, goal_state, depth_limit, uaf_object_base, uaf_object_size, context_end, step_limit=10000):
        self.initial_state = initial_state
        self.depth_add_instrumentation(self.initial_state)
        self.add_instrumentation(self.initial_state)
        self.goal_state = goal_state
        self.ap = proj
        self.simgr = proj.factory.simgr(initial_state)
        plain_constraints, depth_constraints = self.split_constraints(goal_state)
        self.plain_constraints = plain_constraints
        self.depth_constraints = depth_constraints
        self.depth_limited_var = goal_state.record.depth_limited_var
        self.depth_limit = depth_limit
        self.step_limit = step_limit
        self.context_end = context_end

        analyse = StateAnalyse(self.goal_state, uaf_object_base, uaf_object_size)

        self.matrix = analyse.matrix
        self.unresolved_ptrs = analyse.unresolved_ptrs
        self.symbolic_return_point = analyse.symbolic_return_point
        self.vars_in_objs = analyse.vars_in_objs
        self.unresolved_vars = analyse.unresolved_vars
        self.obj_start = analyse.obj_start

        self.analyseReturns()
        self.trainsform_constraints()
        self.constraints_by_var = {}
        for c in self.goal_state.solver.constraints:
            for v in c.variables():
                if v in self.constraints_by_var:
                    self.constraints_by_var[v].append(c)
                else:
                    self.constraints_by_var[v] = [c]


    def analyseReturns(self):
        self.return_constraints = []
        for (d, instr, var) in self.depth_limited_var:
            obj_idx = self.goal_state.record.check_inside_obj_index(var)
            if obj_idx is not None: # returns a pointer
                # get replated object
                # related = self.__get_related_objects(obj_idx)
                c = {
                    'type': 'pointer',
                    'point_to': obj_idx,
                    # 'related' : related,
                }
            else:
                # a value or unused
                c = { 'type': 'value' }
            self.return_constraints.append(c)

    def trainsform_constraints(self):
        # transform constraints of goal_state to memory independent
        replacing_dict = {}
        variable_set = []
        new_variables = []
        vars_in_obj = [[] for o in self.goal_state.record.obj_mem]
        for v in self.goal_state.solver.all_variables:
            addr = None
            size = v.size()
            if str(v).find("uaf") != -1:
                new_variables.append(v)
                continue
            addrs = list(self.goal_state.memory.addrs_for_hash(hash(v)))
            if len(addrs) > 0:
                addr = addrs[0]
            '''
            else:
                # fall into guessing from name
                tmp = str(v).find("mem")
                if tmp != -1:
                    components = (str(v)[tmp:]).split('_')
                    addr = int('0x' + components[1], 16)
            '''
            if addr is not None:
                index = self.check_inside_obj_index(addr)
                if index is not None:
                    variable_set.append(v)
                    offset = addr - self.obj_start[index]
                    newv = self.goal_state.solver.BVS("obj_"+str(index)+"_"+str(offset)+"_"+str(size), size = size, explicit_name=True)
                    replacing_dict[hash(v)] = newv
                    new_variables.append(newv)
                    vars_in_obj[index].append(newv)
                else:
                    new_variables.append(v)
            else:
                new_variables.append(v)

        # replace
        new_constraints = []
        for c in self.goal_state.solver.constraints:
            new_constraints.append(c.replace_dict(replacing_dict, variable_set=variable_set))
        self.goal_state.solver.constraints = new_constraints
        self.goal_state.solver.all_variables = new_variables
        import IPython; IPython.embed()

    def depth_explore(self):
        stop = False
        step = 0
        while not stop:
            to_explore = []
            for a in self.simgr.stashes['active']:
                replaced_var, ret_info = self.is_depth_limit_call(a)
                if replaced_var is not None:
                    # was replaced, now expend
                    # spawn a simgr
                    a.record.inside_dfs_explore = True
                    sub_simgr = dfsSimgr.DfsSimgr(self.ap, a, self.goal_state, replaced_var, ret_info, self.matrix, self.obj_start, self.constraints_by_var)
                    after_ret = sub_simgr.explore()
                    if after_ret is not None:
                        # continue with state after return
                        after_ret.record.inside_dfs_explore = False
                        to_explore.append(after_ret)
                        log.info("[+] matched a depth limited part")
                        import IPython; IPython.embed()
                    else:
                        log.warning("[-] Unable to find a path satisfying the limited part")
                        self.simgr.stashes['unsat'].append(a)
                else:
                    to_explore.append(a)
            self.simgr.stashes['active'] = to_explore
            print("before stepping: ", len(self.simgr.stashes['active']), " active states")
            self.simgr.step(step_func = self.depth_step_func)
            print("after stepping: ", len(self.simgr.stashes['active']), " active states")
            step += 1
            stop = step > self.step_limit or len(self.simgr.stashes['active'])== 0 or len(self.simgr.stashes['primitive'])>0
        log.info("[+] Finished depth explore")
        import IPython; IPython.embed()


    def is_goal_state(self, state):
        return state.addr == self.goal_state.addr and state.record.primitive is not None

    def depth_step_func(self, lsm):
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='active', to_stash='primitive')
        lsm.stash(filter_func=lambda s: s.addr == self.context_end, from_stash='active', to_stash='found')
        return lsm

    def split_constraints(self, state):
        plain = []
        depth_limited = []
        objs = []
        for c in state.solver.constraints:
            found = False
            for l in c.leaf_asts():
                if "depth_limit" in str(l):
                    found = True
                    continue
            if found:
                depth_limited.append(c)
            else:
                plain.append(c)
        return plain, depth_limited

    def depth_add_instrumentation(self, state):
        state.inspect.b('exit', when=angr.BP_BEFORE, action=self.track_successor)

    def add_instrumentation(self,state):
        state.inspect.b('mem_read', when=angr.BP_BEFORE, action=self.track_reads)
        state.inspect.b('mem_read', when=angr.BP_AFTER, action=self.track_after_reads)
        state.inspect.b('mem_write', when=angr.BP_BEFORE, action=self.track_writes)
        state.inspect.b('mem_write', when=angr.BP_AFTER, action=self.track_after_writes)
        state.inspect.b('call', when=angr.BP_BEFORE, action=self.track_call)
        state.inspect.b('exit',when=angr.BP_AFTER, action=self.track_after_jump)

    def is_depth_limit_call(self, state):
        depth = 0
        for c in state.callstack:
            depth += 1
        if depth == self.depth_limit+1 and state.history.jumpkind == 'Ijk_Call':
            if len(self.depth_limited_var)==0:
                print("mismatched call")
                import IPython; IPython.embed()
            (d, instr, var) = self.depth_limited_var[0]
            call_from = state.callstack.call_site_addr
            if call_from == instr:
                ret_info = self.return_constraints[0]
                self.depth_limited_var =  self.depth_limited_var[1:]
                self.return_constraints = self.return_constraints[1:]
                return var, ret_info
            else:
                print("missmathed call")
                import IPython; IPython.embed()
        return None, None

    def __get_related_objects(self, start_index):
        n = len(self.goal_state.record.obj_mem)
        to_add_list = [start_index]
        related = []
        related_objs = []
        while len(to_add_list) > 0:
            obj = to_add_list[0]
            related.append(obj)

            to_do_list = to_add_list[1:]
            for i in range(n):
                if len(self.matrix[obj][i]) > 0 and i not in related:
                    to_do_list.append(i)
        return related




'''
    def __get_variables_of_object(self, obj):
        vars = self.goal_state.solver.all_variables
        vars_of_obj = []
        for v in vars:
            addrs = list(self.goal_state.memory.addrs_for_hash(hash(v)))
            if len(addrs) > 0:
                addr = min(addrs)
                index = self.goal_state.record.check_inside_obj_index(addr)
                if index == obj:
                    vars_of_objs.append((v, addrs))
        return vars_of_obj

    def __variable_map(self):
        vars_in_objs= [[] for i in range(len(self.obj_mem))]
        unresolved = []
        for v in self.vars:
            # get addrs
            addrs = list(self.goal_state.memory.addrs_for_hash(hash(v)))
            if len(addrs) > 0:
                addr = min(addrs)
                index = self.check_inside_obj_index(addr)
                if index is not None:
                    vars_in_objs[index].append((v, addrs))
                else:
                    unresolved.append((v, addrs))
            else:
                unresolved.append((v, addrs))
        return vars_in_objs, unresolved

    def __get_point_matrix(self):
        n = len(self.goal_state.record.obj_mem)
        matrix = [[[] for i in range(n)] for j in range(n)]
        unresolved = []
        for (s,p) in self.goal_state.record.symbolic_pointers:
            pointed_by = None
            for i in range(n):
                if s >= self.goal_state.record.obj_mem[i][0] and s < self.goal_state.record.obj_mem[i][1]:
                    pointed_by = i
                    break

            point_to = None
            for i in range(n):
                if p >= self.goal_state.record.obj_mem[i][0] and p < self.goal_state.record.obj_mem[i][1]:
                    point_to = i
                    break

            if pointed_by is not None and point_to is not None:
                matrix[pointed_by][point_to].append((s,p))
            else:
                unresolved.append((s,p))

        symbolic_return_point = []
        for (d, ins, var) in self.goal_state.record.depth_limited_var:
            idx = self.goal_state.record.check_inside_obj_index(var)
            if idx is not None:
                symbolic_return_point.append((var, idx))

        return matrix, unresolved,symbolic_return_point
'''
