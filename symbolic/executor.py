import angr
import sys
import cle
import pickle
import util
import bpHandlers
import explore
import stateContraints
import traceHelper
import symCallProc
from angr import concretization_strategies
import logging

log = logging.getLogger("symbolic")
log.setLevel('INFO')

logging.getLogger('angr').setLevel('WARNING')

class Executor(util.Util, bpHandlers.BpHandlers, explore.Explore):
    def __init__(self, core_file,
                lib_call_hook = [],
                do_nothing_instr = [],
                avoids = [],
                step_limit=None,
                stop_when_primtive_found=None,
                stop_when_active_more_than=None,
                stop_when_write_primtive_found=None,
                stop_when_control_hijack_found=None,
                continue_with_write_primitive=False,
                continue_with_control_hijack=True,
                log_interval=100, log_file='out', debug=True,
                milestones = [],
                log_step = True):
        self.core_file = core_file
        self.ap = angr.Project(self.core_file, main_opts={'backend': 'elfcore'},rebase_granularity=0x1000, auto_load_libs=False)
        self.write_primitive = []
        self.paths_to_write_primitive = 0
        self.control_hijack = []
        self.paths_to_control_hijack = 0
        self.step_limit= step_limit
        self.stop_when_primtive_found= stop_when_primtive_found
        self.stop_when_active_more_than = stop_when_active_more_than
        self.stop_when_write_primtive_found = stop_when_write_primtive_found
        self.stop_when_control_hijack_found = stop_when_control_hijack_found
        self.continue_with_write_primitive = continue_with_write_primitive
        self.continue_with_control_hijack = continue_with_control_hijack
        self.log_interval =log_interval
        self.log_file=log_file
        self.debug = debug
        self.milestones = milestones
        self.log_step = log_step

        for (addr, lib, func) in lib_call_hook:
            if lib in angr.SIM_PROCEDURES and func in angr.SIM_PROCEDURES[lib]:
                log.info("[+] Hooking SimProcedure for "+ func+ ' in '+ lib)
                self.ap.hook(addr, angr.SIM_PROCEDURES[lib][func]())
            else:
                log.warning('[-] No SimProcedure implemented for '+ func+ ' in '+ lib)

        for a in do_nothing_instr:
            self.ap.hook(a, angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained']())

        for a in milestones:
            self.ap.hook(a, traceHelper.TraceHelper())

        self.avoids = avoids

    def setup(self):
        options = {
            angr.options.SYMBOLIC_WRITE_ADDRESSES,
            angr.options.REVERSE_MEMORY_HASH_MAP,
            angr.options.REVERSE_MEMORY_NAME_MAP,
            angr.options.TRACK_SOLVER_VARIABLES,
            angr.options.NO_SYMBOLIC_JUMP_RESOLUTION,
            angr.options.CONSERVATIVE_READ_STRATEGY
        }
        ss = angr.factory.AngrObjectFactory(self.ap).blank_state(add_options=options)
        self.dump_state(ss)
        # Get the elfcore_object
        elfcore_object = None
        for o in self.ap.loader.all_objects:
            if type(o) == cle.backends.elf.elfcore.ELFCore:
                elfcore_object = o
                break
        if elfcore_object is None:
            error

        # Set the reg values from the elfcore_object to the sim state, realizing that not all
        # of the registers will be supported (particularly some segment registers)
        for regval in elfcore_object.initial_register_values():
            try:
                log.debug(regval[0] + ": "+ hex(regval[1]))
                setattr(ss.regs, regval[0], ss.solver.BVV(regval[1],64))
            except Exception:
                log.error("[-] there is no " + regval[0] + " in state's registers")

        ss.register_plugin('record', stateContraints.StateContraints())
        self.ap.hook(0xfffffffffffff00e, symCallProc.SymCallProc(symbolic_return=True, returns=True, is_syscall=False, display_name='symbolic_call_', is_function=True))
        self.ap.hook(0xfffffffffffff01e, SIM_PROCEDURES['stubs']['ReturnUnconstrained'](display_name='depth_limit_'))
        return ss

    def run(self, uaf_object_base, uaf_object_size, context_end):
        self.uaf_object_base = uaf_object_base
        self.uaf_object_size = uaf_object_size
        self.context_end = context_end

        ss = self.setup()
        ss.memory.read_strategies = [concretization_strategies.SimConcretizationStrategySingle(exact=True),
                                    concretization_strategies.SimConcretizationStrategyObjectSingle(),
                                    concretization_strategies.SimConcretizationStrategyObjectHeap(),
                                    concretization_strategies.SimConcretizationStrategyObjectMax()]

        ss.memory.write_strategies = [concretization_strategies.SimConcretizationStrategySingle(exact=True),
                                    concretization_strategies.SimConcretizationStrategyObjectSingle(),
                                    concretization_strategies.SimConcretizationStrategyObjectHeap(),
                                    concretization_strategies.SimConcretizationStrategyObjectMax()]
        self.add_instrumentation(ss)

        # setup symbolic memory
        log.info('[+] setting memory at ' + hex(self.uaf_object_base) + ' of length '+ str(self.uaf_object_size) + ' bytes to symbolic value')
        self.uaf_bytes = []
        for i in range(self.uaf_object_size):
            symbolic_byte = ss.solver.BVS("uaf_obj" + str(i), 8)
            self.uaf_bytes.append(symbolic_byte)
            ss.memory.store(self.uaf_object_base+i, symbolic_byte, inspect=False)

        # ss.record.add_tainted_mem(ss.solver.BVV(self.uaf_object_base, 64), ss.solver.BVV(self.uaf_object_base+ self.uaf_object_size, 64))
        ss.record.add_obj_mem((self.uaf_object_base, self.uaf_object_base+ self.uaf_object_size))
        self.dump_state(ss)
        self.step = 0
        log.info('[+] finishing setting up, start explore?')
        import IPython; IPython.embed()
        self.explore(ss)

    def add_instrumentation(self,state):
        state.inspect.b('mem_read', when=angr.BP_BEFORE, action=self.track_reads)
        state.inspect.b('mem_read', when=angr.BP_AFTER, action=self.track_after_reads)
        state.inspect.b('mem_write', when=angr.BP_BEFORE, action=self.track_writes)
        state.inspect.b('mem_write', when=angr.BP_AFTER, action=self.track_after_writes)
        state.inspect.b('call', when=angr.BP_BEFORE, action=self.track_call)
        # state.inspect.b('symbolic_variable', when=angr.BP_AFTER, action=self.track_symbolic_variable)
        # state.inspect.b('address_concretization', when=angr.BP_AFTER, action=self.track_after_address_concretization)
        state.inspect.b('exit',when=angr.BP_AFTER, action=self.track_after_jump)
        state.inspect.b('syscall',when=angr.BP_BEFORE, action=self.track_syscall)

    def add_control_hijack(self, state):
        self.paths_to_control_hijack += 1
        for c in self.control_hijack:
            if c.scratch.exit_ins_addr == state.scratch.exit_ins_addr:
                return

        self.control_hijack.append(state)


    def add_write_primitive(self, state):
        self.paths_to_write_primitive += 1
        for w in self.write_primitive:
            if w.addr == state.addr:
                return
        self.write_primitive.append(state)
