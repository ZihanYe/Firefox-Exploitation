import angr
import sys
import socket
import cle
import util
import bpHandlers
import explore
import stateContraints
import traceHelper
import symCallProc
import limitedDepth
from angr import concretization_strategies
import logging

log = logging.getLogger("symbolic")
log.setLevel('INFO')

logging.getLogger('angr').setLevel('WARNING')

class Executor(util.Util, bpHandlers.BpHandlers, explore.Explore):
    def __init__(self, core_file,
                lib_call_hook = [],
                do_nothing_instr = [],
                avoids = [], #[addr]
                shellcodes = [], # [(base_addr, binary)]
                stack = None, # (stack_top, binary)
                gdb_server = None, # (hostname, port)
                depth_limit = None,
                step_limit=None,
                stop_when_primtive_found=None,
                stop_when_active_more_than=None,
                stop_when_write_primtive_found=None,
                stop_when_control_hijack_found=None,
                continue_with_write_primitive=False,
                continue_with_control_hijack=True,
                log_interval=100, log_file='out', debug=True,
                milestones = [],
                log_step = True):
        self.core_file = core_file
        self.ap = angr.Project(self.core_file, main_opts={'backend': 'elfcore'},rebase_granularity=0x1000, auto_load_libs=False, support_selfmodifying_code=True)
        self.write_primitive = []
        self.paths_to_write_primitive = 0
        self.control_hijack = []
        self.paths_to_control_hijack = 0
        self.step_limit= step_limit
        self.stop_when_primtive_found= stop_when_primtive_found
        self.stop_when_active_more_than = stop_when_active_more_than
        self.stop_when_write_primtive_found = stop_when_write_primtive_found
        self.stop_when_control_hijack_found = stop_when_control_hijack_found
        self.continue_with_write_primitive = continue_with_write_primitive
        self.continue_with_control_hijack = continue_with_control_hijack
        self.log_interval =log_interval
        self.log_file=log_file
        self.debug = debug
        self.debug_step = None
        self.milestones = milestones
        self.log_step = log_step

        self.depth_limit = depth_limit
        for (addr, lib, func) in lib_call_hook:
            if lib in angr.SIM_PROCEDURES and func in angr.SIM_PROCEDURES[lib]:
                log.info("[+] Hooking SimProcedure for "+ func+ ' in '+ lib)
                self.ap.hook(addr, angr.SIM_PROCEDURES[lib][func]())
            else:
                log.warning('[-] No SimProcedure implemented for '+ func+ ' in '+ lib)

        for a in do_nothing_instr:
            self.ap.hook(a, angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained']())

        for a in milestones:
            self.ap.hook(a, traceHelper.TraceHelper())

        self.avoids = avoids
        # (baseaddr, binary file)
        self.shellcodes = shellcodes
        self.stack = stack

        if gdb_server is not None:
            self.gdb_port = socket.socket()
            self.gdb_port.connect((gdb_server[0], gdb_server[1]))

    def setup(self):
        options = {
            angr.options.SYMBOLIC_WRITE_ADDRESSES,
            angr.options.REVERSE_MEMORY_HASH_MAP,
            # angr.options.REVERSE_MEMORY_NAME_MAP,
            angr.options.BYPASS_UNSUPPORTED_IRDIRTY,
            angr.options.TRACK_SOLVER_VARIABLES,
            angr.options.NO_SYMBOLIC_JUMP_RESOLUTION,
            angr.options.CONSERVATIVE_READ_STRATEGY
        }
        ss = angr.factory.AngrObjectFactory(self.ap).blank_state(add_options=options)
        self.dump_state(ss)
        # Get the elfcore_object
        elfcore_object = None
        for o in self.ap.loader.all_objects:
            if type(o) == cle.backends.elf.elfcore.ELFCore:
                elfcore_object = o
                break
        if elfcore_object is None:
            error

        # Set the reg values from the elfcore_object to the sim state, realizing that not all
        # of the registers will be supported (particularly some segment registers)
        for regval in elfcore_object.initial_register_values():
            try:
                log.debug(regval[0] + ": "+ hex(regval[1]))
                setattr(ss.regs, regval[0], ss.solver.BVV(regval[1],64))
            except Exception:
                log.error("[-] there is no " + regval[0] + " in state's registers")

        ss.register_plugin('record', stateContraints.StateContraints())
        self.ap.hook(0xfffffffffffff00e, symCallProc.SymCallProc(symbolic_return=True, returns=True, is_syscall=False, display_name='symbolic_call_', is_function=True))
        # self.ap.hook(0xfffffffffffff01e, angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'](display_name='depth_limit_'))
        self.ap.hook(0xfffffffffffff01e, limitedDepth.LimitedDepth())

        # shellcode
        for (base_addr, binfile) in self.shellcodes:
            with open(binfile, mode='rb') as file:
                bytes = file.read()
                ss.memory.store(base_addr, bytes, inspect=False)
        # stack
        if self.stack is not None:
            ss.gdb.set_stack(self.stack[1], self.stack[0])
        return ss

    def run(self, uaf_object_base, uaf_object_size, context_end, precondition=[]):
        self.uaf_object_base = uaf_object_base
        self.uaf_object_size = uaf_object_size
        self.context_end = context_end

        ss = self.setup()
        ss.memory.read_strategies = [concretization_strategies.SimConcretizationStrategySingle(exact=True),
                                    concretization_strategies.SimConcretizationStrategyObjectSingle(),
                                    concretization_strategies.SimConcretizationStrategyObjectHeap(),
                                    concretization_strategies.SimConcretizationStrategyObjectMax()]

        ss.memory.write_strategies = [concretization_strategies.SimConcretizationStrategySingle(exact=True),
                                    concretization_strategies.SimConcretizationStrategyObjectSingle(),
                                    concretization_strategies.SimConcretizationStrategyObjectHeap(),
                                    concretization_strategies.SimConcretizationStrategyObjectMax()]


        # setup symbolic memory
        log.info('[+] setting memory at ' + hex(self.uaf_object_base) + ' of length '+ str(self.uaf_object_size) + ' bytes to symbolic value')
        self.uaf_bytes = []
        for i in range(self.uaf_object_size):
            preconditioned = False
            for (off, nbyte, v) in precondition:
                if off <= i and off+nbyte > i:
                    preconditioned = True

            if not preconditioned:
                symbolic_byte = ss.solver.BVS("uaf_obj" + str(i), 8)
                self.uaf_bytes.append(symbolic_byte)
                ss.memory.store(self.uaf_object_base+i, symbolic_byte, inspect=False)

        for (off, nbyte, v) in precondition:
            value = ss.solver.BVV(v, nbyte*self.ap.arch.byte_width)
            ss.memory.store(self.uaf_object_base+off, value)

        # ss.record.add_tainted_mem(ss.solver.BVV(self.uaf_object_base, 64), ss.solver.BVV(self.uaf_object_base+ self.uaf_object_size, 64))
        ss.record.add_obj_mem((self.uaf_object_base, self.uaf_object_base+ self.uaf_object_size))

        self.initial_state = ss.copy()
        self.add_instrumentation(ss)

        self.dump_state(ss)
        self.step = 0
        log.info('[+] finishing setting up, start explore?')
        import IPython; IPython.embed()
        self.explore(ss)

    def add_instrumentation(self,state):
        state.inspect.b('mem_read', when=angr.BP_BEFORE, action=self.track_reads)
        state.inspect.b('mem_read', when=angr.BP_AFTER, action=self.track_after_reads)
        state.inspect.b('mem_write', when=angr.BP_BEFORE, action=self.track_writes)
        state.inspect.b('mem_write', when=angr.BP_AFTER, action=self.track_after_writes)
        state.inspect.b('call', when=angr.BP_BEFORE, action=self.track_call)
        # state.inspect.b('symbolic_variable', when=angr.BP_AFTER, action=self.track_symbolic_variable)
        # state.inspect.b('address_concretization', when=angr.BP_AFTER, action=self.track_after_address_concretization)
        state.inspect.b('exit',when=angr.BP_AFTER, action=self.track_after_jump)
        state.inspect.b('syscall',when=angr.BP_BEFORE, action=self.track_syscall)

    def add_control_hijack(self, state):
        self.paths_to_control_hijack += 1
        for c in self.control_hijack:
            if c.scratch.exit_ins_addr == state.scratch.exit_ins_addr:
                return

        self.control_hijack.append(state)

    def add_write_primitive(self, state):
        self.paths_to_write_primitive += 1
        for w in self.write_primitive:
            if w.addr == state.addr:
                return
        self.write_primitive.append(state)

    def resolve_address(self, state, addr):
        if self.gdb_port is not None:
            log.info('[+] Querying gdb server for a page starting at '+ str(addr))
            if not self.check_addr(addr):
                return False
            try:
                self.gdb_port.send(hex(addr).encode())
                data = self.gdb_port.recv(20000)
                print("[+] Write to memory")
                if len(data) > 0:
                    state.memory.store(addr, data, inspect=False, endness='Iend_BE')
                    return True
            except Exception as e:
                print(str(e))
                return False
        return False

    def get_instr(self, addr):
        if self.gdb_port is not None:
            if not self.check_addr(addr):
                return None
            try:
                cmd = "instr " + hex(addr)
                self.gdb_port.send(cmd.encode())
                data = self.gdb_port.recv(20000).decode()
                return data
            except Exception as e:
                print(str(e))
        return None

    def check_addr(self, addr):
        for o in self.ap.loader.all_elf_objects:
            if o.contains_addr(addr):
                return True
        return False
