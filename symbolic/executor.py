import angr
import sys
import cle
import pickle
import util
import bpHandlers
import explore
import stateContraints
import symCallProc
from angr import concretization_strategies

class Executor(util.Util, bpHandlers.BpHandlers, explore.Explore):
    def __init__(self, core_file, stop_limit=None, stop_when_primtive_found=None, stop_when_active_more_than=None):
        self.core_file = core_file
        self.ap = angr.Project(self.core_file, main_opts={'backend': 'elfcore'},rebase_granularity=0x1000)
        self.write_primitive = []
        self.control_hijack = []
        self.step_limit= step_limit
        self.stop_when_primtive_found= stop_when_primtive_found
        self.stop_when_active_more_than = stop_when_active_more_than

    def setup(self):
        options = {
            angr.options.SYMBOLIC_WRITE_ADDRESSES,
            angr.options.REVERSE_MEMORY_NAME_MAP,
            angr.options.TRACK_SOLVER_VARIABLES,
        }
        ss = angr.factory.AngrObjectFactory(self.ap).blank_state(add_options=options)
        self.dump_state(ss)
        # Get the elfcore_object
        elfcore_object = None
        for o in self.ap.loader.all_objects:
            if type(o) == cle.backends.elf.elfcore.ELFCore:
                elfcore_object = o
                break
        if elfcore_object is None:
            error

        # Set the reg values from the elfcore_object to the sim state, realizing that not all
        # of the registers will be supported (particularly some segment registers)
        for regval in elfcore_object.initial_register_values():
            try:
                print(regval[0] + ": "+ hex(regval[1]))
                setattr(ss.regs, regval[0], ss.solver.BVV(regval[1],64))
            except Exception:
                print("[+] there is no " + regval[0] + " in state's registers")

        ss.register_plugin('record', stateContraints.StateContraints())
        self.ap.hook(0xfffffffffffff00e, symCallProc.SymCallProc(symbolic_return=True, returns=True, is_syscall=False, display_name='symbolic_call_', is_function=True))
        return ss

    def run(self, uaf_object_base, uaf_object_size, context_end):
        self.uaf_object_base = uaf_object_base
        self.uaf_object_size = uaf_object_size
        self.context_end = context_end

        ss = self.setup()
        strategy = concretization_strategies.SimConcretizationStrategyObject()
        ss.memory.read_strategies.insert(0, strategy)
        ss.memory.write_strategies.insert(0, strategy)
        self.add_instrumentation(ss)

        # setup symbolic memory
        print('[+] setting memory at ' + hex(self.uaf_object_base) + ' of length '+ str(self.uaf_object_size) + ' bytes to symbolic value')
        self.uaf_bytes = []
        for i in range(self.uaf_object_size):
            symbolic_byte = ss.solver.BVS("uaf_obj" + str(i), 8)
            self.uaf_bytes.append(symbolic_byte)
            ss.memory.store(self.uaf_object_base+i, symbolic_byte, inspect=False)

        ss.record.add_tainted_mem(ss.solver.BVV(self.uaf_object_base, 64), ss.solver.BVV(self.uaf_object_size, 64))
        self.dump_state(ss)
        self.explore(ss)

    def add_instrumentation(self,state):
        state.inspect.b('mem_read', when=angr.BP_BEFORE, action=self.track_reads)
        state.inspect.b('mem_read', when=angr.BP_AFTER, action=self.track_after_reads)
        state.inspect.b('mem_write', when=angr.BP_BEFORE, action=self.track_writes)
        state.inspect.b('mem_write', when=angr.BP_AFTER, action=self.track_after_writes)
        state.inspect.b('call', when=angr.BP_BEFORE, action=self.track_call)
        state.inspect.b('symbolic_variable', when=angr.BP_AFTER, action=self.track_symbolic_variable)
        state.inspect.b('address_concretization', when=angr.BP_AFTER, action=self.track_after_address_concretization)
