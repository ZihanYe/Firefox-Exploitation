import angr
import logging
import time

log = logging.getLogger("symbolic")

class Solution:
    def find_solution(self, state, primitive=None, target_address=None, target_content=None):
        if not state.solver.satisfiable():
            # if state is not statisfiable at all, return None
            return None
        com = state.controlled_object_map
        obj_offset = [0]
        # initial target object is mapped to itself
        base_addr  = com.object_addrs[0]
        max_offset = com.object_region[0][1] - base_addr
        constrained_bytes = com.get_constrainted_bytes(com, 0)
        # constrained_bytes is a list of offsets where object i has a constrained byte

        for i in range(1, com.n):
            vs = com.get_constrainted_bytes(i)
            # vs is a list of offsets where object i has a constrained byte
            min_off = min(vs); max_off = max(vs)
            base_offset = max(0, min_off*(-1))
            while base_offset + max_off <= max_offset:
                ok = True
                for byte in vs:
                    if byte + base_offset in constrained_bytes:
                        ok = False; break
                if not ok:
                    base_offset += 8 # move the base address and re-try
                else:
                    break

            if base_offset + max_off <= max_offset:
                obj_offset.append(base_offset)
                for byte in vs:
                    constrained_bytes.append(byte)
            else:
                return None # cannot fit object i

        # convert variables
        rd = {}
        for i in range(1, com.n):
            for v in com.object_vars[i]:
                # for each variable
                index, offset = com.get_obj_offset_for_var(v)
                v_to_replace = com.get_object_variable(0, offset+obj_offset[i], v.size()//8)
                rd[v.cache_key] = v_to_replace

        final_constraints = []
        # transform constraints
        for c in state.solver.constraints:
            # ignore point-to relationship constraints
            if c.op == '__eq__':
                if com.check_inside_obj_index(c.args[0]) is not None:
                    continue
                elif com.check_inside_obj_index(c.args[1]) is not None:
                    continue
            final_constraints.append(c.replace_dict(rd))

        # add constraints for pointers
        for i in range(com.n):
            for offset, point_to in com.object_pointers[i].items():
                pointer = com.get_object_pointer(0, offset+obj_offset[i])
                constraint = pointer == (base_addr + obj_offset[point_to])
                final_constraints.append(constraint)

        # add constraint of target address
        # (and target content if the state has a controlled write)
        if primitive is not None:
            if primitive['type'] == 'CONTROL':
                constraints = [primitive['call'] == target_addr]
            elif primitive['type'] == 'JUMP':
                constraints = [primitive['jump_to'] == target_addr]
            else:
                constraints = [primitive['write_to'] == target_addr]
                if target_content is not None:
                    constraints.append(primitive['value'] == target_content)
            final_constraints.extend([c.replace_dict(rd) for c in constraints])

        # solve
        state.solver.reload_solver(final_constraints)
        if not state.solver.satisfiable():
            return None
        # 0x0 as default value
        bytes = [0x0 for i in range(max_offset)]
        for b in constrained_bytes:
            # get variable representing the byte at offset b
            var = com.get_object_variable(0, b, 1)
            value = state.solver.eval_upto(var, 1)
            if len(value) == 0:
                return None
            bytes[b] = value

        return bytes
