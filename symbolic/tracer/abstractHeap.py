import angr
import logging
log = logging.getLogger("symbolic")

class AbstractHeap(angr.SimStatePlugin):
    def __init__(self):
        super(AbstractHeap, self).__init__()
        self.object_addrs = []
        self.object_region = []
        self.n = 0
        # [offset -> index]
        self.object_pointers = []
        self.object_vars = []

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        a = AbstractHeap();
        a.object_addrs  = self.object_addrs.copy()
        a.object_region = self.object_region.copy()
        a.n = self.n
        a.object_pointers = self.object_pointers.copy()
        a.object_vars = self.object_vars.copy()
        return a

    def add_an_object(self, base_addr, region):
        self.object_addrs.append(base_addr)
        self.object_region.append(region)
        self.n += 1
        self.object_pointers.append({})
        self.object_vars.append(set())

    def add_point_to(self, pointer_addr, points_to):
        s = self.check_inside_obj_index(pointer_addr)
        if s is None:
            return
        p = self.check_inside_obj_index(points_to)
        if p is None:
            return
        offset = self.state.solver.eval_one(pointer_addr - self.object_addrs[s])
        oldpointto = self.object_pointers[s].get(offset, None)
        if oldpointto is not None and oldpointto == p:
            log.warning("[-] pointing to a different object than before, why?")
            import IPython; IPython.embed()
        self.object_pointers[s][offset] = p

    def add_var(self, var):
        addr = self.get_addr_for_var(var)
        if addr is not None:
            index = self.check_inside_obj_index(addr)
            if index is not None:
                self.object_vars[index].add(var)


    def check_inside_obj(self, addr):
        try:
            if not isinstance(addr, int) and addr.size() != 64:
                return False
            for (a,b) in self.object_region:
                sa = self.state.solver.BVV(a, size=64)
                sb = self.state.solver.BVV(b, size=64)
                # if self.state.solver.eval(a <= addr) and self.state.solver.eval(b > addr):
                if self.state.solver.eval(sa <= addr) and self.state.solver.eval(sb > addr):
                    return True
        except Exception as e:
            log.error("[-] EXCEPTION during checking "+ str(addr)+ " is inside a controlled object or not")
            print(str(e))
            import IPython; IPython.embed()
        return False

    def check_inside_obj_index(self, addr):
        try:
            if not isinstance(addr, int) and addr.size() != 64:
                return None
            for i in range(len(self.object_region)):
                (a,b) = self.object_region[i]
                if self.state.solver.eval(self.state.solver.BVV(a, size=64) <= addr) and self.state.solver.eval(self.state.solver.BVV(b, size=64) > addr):
                    return i
        except Exception as e:
            log.error( "[-] EXCEPTION during checking "+ str(addr)+ " is inside a controlled object or not")
            print(str(e))
            import IPython; IPython.embed()
        return None

    def get_addr_for_var(self, var):
        addr = None
        addrs = list(self.state.memory.addrs_for_hash(hash(var)))
        if len(addrs) > 0:
            addr = min(addrs)
        else:
            # fall into guessing from name
            tmp = str(var).find("mem")
            if tmp != -1:
                components = (str(var)[tmp:]).split('_')
                addr = int('0x' + components[1], 16)
            else:
                tmp = str(var).find("uaf_obj")
                if tmp != -1:
                    index = int(str(var)[tmp+7:].split('_')[0])
                    addr = self.object_addrs[0]+index
        return addr


from angr.sim_state import SimState
SimState.register_default('abstractHeap', AbstractHeap)
