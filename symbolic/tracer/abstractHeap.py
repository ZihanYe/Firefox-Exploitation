import angr
import logging
log = logging.getLogger("symbolic")

class AbstractHeap(angr.SimStatePlugin):
    def __init__(self, mem_endness):
        super(AbstractHeap, self).__init__()
        self.object_addrs = []
        self.object_region = []
        self.n = 0
        # [{offset -> index}]
        self.object_pointers = []
        # [[(parent, offset)]]
        self.object_parents = []
        self.object_vars = []
        self.symbolic_pointer = []
        self.mem_endness = mem_endness

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        a = AbstractHeap(self.mem_endness);
        a.object_addrs  = self.object_addrs.copy()
        a.object_region = self.object_region.copy()
        a.n = self.n
        a.object_pointers = self.object_pointers.copy()
        a.object_parents = self.object_parents.copy()
        a.object_vars = self.object_vars.copy()
        a.symbolic_pointer = self.symbolic_pointer.copy()
        return a

    def add_an_object(self, base_addr, region):
        self.object_addrs.append(base_addr)
        self.object_region.append(region)
        self.n += 1
        self.object_pointers.append({})
        self.object_parents.append([])
        self.object_vars.append(set())

    def add_point_to(self, pointer_addr, points_to):
        s = self.check_inside_obj_index(pointer_addr)
        if s is None:
            return False
        p = self.check_inside_obj_index(points_to)
        if p is None:
            return False
        offset = self.state.solver.eval_one(pointer_addr - self.object_addrs[s])
        oldpointto = self.object_pointers[s].get(offset, None)
        if oldpointto is not None and oldpointto != p:
            log.warning("[-] pointing to a different object than before, why?")
            import IPython; IPython.embed()
        self.object_pointers[s][offset] = p
        self.object_parents[p].append((s,offset))
        return True

    def add_symbolic_pointer(self, var):
        p = self.check_inside_obj_index(var)
        if p is None:
            return
        self.symbolic_pointer.append((var, p))

    def add_var(self, var):
        addr = self.get_addr_for_var(var)
        if addr is not None:
            index = self.check_inside_obj_index(addr)
            if index is not None:
                self.object_vars[index].add(var)

    def get_concrete_addr(self, obj_idx, offset):
        return self.object_addrs[obj_idx] + offset

    def get_object_variable(self, obj_idx, offset, size): # size in bytes
        addr = self.get_concrete_addr(obj_idx, offset)
        v = self.state.memory.load(addr, size= size, inspect=False)
        return v

    def get_object_pointer(self, obj_idx, offset):
        addr = self.get_concrete_addr(obj_idx,offset)
        return self.state.memory.load(addr, size=8, inspect=False, endness = self.mem_endness)


    def check_inside_obj(self, addr):
        try:
            if not isinstance(addr, int) and addr.size() != 64:
                return False
            for (a,b) in self.object_region:
                sa = self.state.solver.BVV(a, size=64)
                sb = self.state.solver.BVV(b, size=64)
                # if self.state.solver.eval(a <= addr) and self.state.solver.eval(b > addr):
                if self.state.solver.eval(sa <= addr) and self.state.solver.eval(sb > addr):
                    return True
        except Exception as e:
            log.error("[-] EXCEPTION during checking "+ str(addr)+ " is inside a controlled object or not")
            print(str(e))
            import IPython; IPython.embed()
        return False

    def check_inside_obj_index(self, addr):
        try:
            if not isinstance(addr, int) and addr.size() != 64:
                return None
            for i in range(len(self.object_region)):
                (a,b) = self.object_region[i]
                if self.state.solver.eval(self.state.solver.BVV(a, size=64) <= addr) and self.state.solver.eval(self.state.solver.BVV(b, size=64) > addr):
                    return i
        except Exception as e:
            log.error( "[-] EXCEPTION during checking "+ str(addr)+ " is inside a controlled object or not")
            print(str(e))
            import IPython; IPython.embed()
        return None

    def get_addr_for_var(self, var):
        if not self.state.solver.symbolic(var):
            return None
        addr = None
        addrs = list(self.state.memory.addrs_for_hash(hash(var)))
        if len(addrs) > 0:
            addr = min(addrs)
        else:
            # fall into guessing from name
            tmp = str(var).find("mem")
            if tmp != -1:
                components = (str(var)[tmp:]).split('_')
                addr = int('0x' + components[1], 16)
            else:
                tmp = str(var).find("uaf_obj")
                if tmp != -1:
                    index = int(str(var)[tmp+7:].split('_')[0])
                    addr = self.object_addrs[0]+index
        return addr

    def get_obj_offset_for_var(self, var):
        if not self.state.solver.symbolic(var):
            return None, None
        addr = self.get_addr_for_var(var)
        if addr is not None:
            index = self.check_inside_obj_index(addr)
            if index is not None:
                offset = addr - self.object_addrs[index]
                return index, offset
        return None, None

    def is_symbolic_pointer(self, var):
        for (v, p) in self.symbolic_pointer:
            if v is var:
                return p
        return None


from angr.sim_state import SimState
SimState.register_default('abstractHeap', AbstractHeap)
