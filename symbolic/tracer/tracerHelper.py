import angr
import logging
log = logging.getLogger("symbolic")
log.setLevel('INFO')

class TracerHelper(angr.SimStatePlugin):
    def __init__(self, guide_state, trace_idx, goal_call_stack, heap_match={}, reverse_heap_match={}, inside_lazy_solver=False):
        self.trace_idx = trace_idx
        self.goal_call_stack = goal_call_stack
        self.symbolic_returns = None
        self.symbolic_returns_resolved = 0
        self.guide_state = guide_state
        # from object of self.state to object of guide_state
        self.heap_match = heap_match
        self.heap_match[0] = 0
        # from object of guide_state to object of self.state
        self.reverse_heap_match = reverse_heap_match
        self.reverse_heap_match[0] = 0
        self.inside_lazy_solver = inside_lazy_solver
        self.global_replacing_dict = {}

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        th= TracerHelper(self.guide_state, self.trace_idx, self.goal_call_stack, self.heap_match.copy(), self.reverse_heap_match.copy(), inside_lazy_solver=self.inside_lazy_solver)
        th.symbolic_returns = self.symbolic_returns
        th.symbolic_returns_resolved = self.symbolic_returns_resolved
        th.global_replacing_dict = self.global_replacing_dict.copy()
        return th

    def match_a_heap_object(self, index):
        matched = self.heap_match.get(index, None)
        if matched is not None:
            return True
        for (parent, offset) in self.state.abstractHeap.object_parents[index]:
            matched_parent = self.heap_match.get(parent, None)
            if matched_parent is not None:
                matched_child = self.guide_state.abstractHeap.object_pointers[matched_parent].get(offset, None)
                if matched is not None and matched != matched_child:
                    log.error("parents pointing to different object, not sure what to match")
                    return False
                else:
                    matched = matched_child
        if matched is None:
            print("No corresponding object found in guide state")
            return False
        self.heap_match[index] = matched
        self.reverse_heap_match[matched] = index
        return True

    def match_heap(self):
        todo = [0]
        done = []
        import IPython; IPython.embed()
        while len(todo) > 0:
            index = todo.pop(0)
            success = self.match_a_heap_object(index)
            if not success:
                print("fail to match a heap object ", index)
            else:
                done.append(index)
                for offset, child in self.state.abstractHeap.object_pointers[index].items():
                    if child not in done:
                        todo.append(child)

    def match_a_heap_object_recursive(self, index):
        if self.heap_match.get(index, None) is not None:
            return True
        parents = self.state.abstractHeap.object_parents[index]
        predecessors = [index]
        while len(parents) > 0:
            if self.match_a_heap_object(parents[0][0]):
                break
            else:
                predecessors.append(parents[0][0])
                parents = self.state.abstractHeap.object_parents[parents[0][0]]
        predecessors.reverse()
        for i in predecessors:
            if not self.match_a_heap_object(i):
                log.warning("fail to match a heap object")
                return False
        return True

    def check_constraints_sat(self, cs):
        # transform
        replace_dict = {}
        replace_dict.update(self.global_replacing_dict)
        for c in cs:
            for l in c.leaf_asts():
                if l.cache_key in replace_dict:
                    continue
                obj, offset = self.state.abstractHeap.get_obj_offset_for_var(l)
                if obj is not None:
                    matched_obj = self.heap_match.get(obj, None)
                    if matched_obj is not None:
                        v = self.guide_state.abstractHeap.get_object_variable(matched_obj, offset, l.size()//8)
                        replace_dict[l.cache_key] = v
        new_cs = []
        for c in cs:
            new_c = c.replace_dict(replace_dict)
            new_cs.append(new_c)
        return self.guide_state.solver.satisfiable(extra_constraints=new_cs)


    def check_ret_value(self, ret_val):
        if self.symbolic_returns is None or len(self.symbolic_returns) <= self.symbolic_returns_resolved:
            log.error("fail to match a symbolic return")
            import IPython; IPython.embed()
            return True
        ret_info = self.symbolic_returns[self.symbolic_returns_resolved]
        print("checking return symbol: ", ret_info['symbol'], " with value ", ret_val)
        self.symbolic_returns_resolved += 1
        if len(ret_info['constraints']) == 0:
            return True
        if ret_info['type'] == 'v':
            # returns a value
            return self.check_ret_plain_value(ret_info, ret_val)
        else:
            return self.check_ret_object(ret_info, ret_val)

    def check_ret_object(self, ret_info, ret_val):
        # TODO: check objects, not sure if needed
        # if concrete object then return True
        # if uninitialised object then return True
        # intialised -> then add
        # check if indeed an address
        import IPython; IPython.embed()
        if self.state.solver.symbolic(ret_val):
            # symbolic value
            if ret_val.size() != 64:
                return False
            vs = self.state.solver.eval_upto(ret_val, 2)
            if len(vs) == 1 and not self.state.abstractHeap.check_inside_obj(vs[0]):
                return False
        elif not self.state.abstractHeap.check_inside_obj(ret_val):
            # concrete value AND not in controlled memory regions
            t = self.state.memory.load(ret_val, size=1, inspect=False)
            if self.state.solver.symbolic(t) and t.uninitialised:
                return False
            if isinstance(ret_val, int):
                ret_val = self.state.solver.BVV(ret_val, size=64)
        self.global_replacing_dict[ret_info['symbol'].cache_key] = ret_val
        return True

    def check_ret_plain_value(self, ret_info, ret_val):
        # transform constraints about that value
        replace_dict = {}
        # if not self.state.solver.symbolic(ret_val):
        #     ret_val = self.state.solver.BVV(ret_val, size=64)
        self.global_replacing_dict[ret_info['symbol'].cache_key] = ret_val
        replace_dict.update(self.global_replacing_dict)
        related_constraints = []
        for c in ret_info['constraints']:
            add = True
            for l in c.leaf_asts():
                if l is ret_info['symbol']:
                    continue
                obj, offset = self.guide_state.abstractHeap.get_obj_offset_for_var(l)
                if obj is not None:
                    matched_obj = self.reverse_heap_match.get(obj, None)
                    if obj is not None:
                        # no corresponding object inside current state
                        add = False
                        break
                    else:
                        size = l.size()//8
                        v = self.state.abstractHeap.get_object_variable(matched_obj, offset, size)
                        replace_dict[l.cache_key] = v
            if add:
                related_constraints.append(c.replace_dict(replace_dict))
        related_constraints.extend(self.state.solver.constraints)
        self.state.solver.reload_solver(constraints=related_constraints)
        return self.state.solver.satisfiable()

    def init_symbolic_returns_info(self, ret_symbols):
        self.symbolic_returns = []
        for r in ret_symbols:
            index = self.guide_state.abstractHeap.is_symbolic_pointer(r)
            if index is None:
                # value
                info = {
                    'type': 'v',
                    'symbol': r,
                    'constraints': [],
                }
            else:
                info = {
                    'type': 'p',
                    'symbol': r,
                    'point_to': index,
                    'constraints': [],
                }
            constraints = []
            for c in self.guide_state.solver.constraints:
                for l in c.leaf_asts():
                    if l is r:
                        constraints.append(c)
                        break
            info['constraints'] = constraints
            self.symbolic_returns.append(info)
