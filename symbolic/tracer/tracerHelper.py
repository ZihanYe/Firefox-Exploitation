import angr
import logging
log = logging.getLogger("symbolic")

class TracerHelper(angr.SimStatePlugin):
    def __init__(self, guide_state, trace_idx, goal_call_stack, heap_match={}, reverse_heap_match={}, inside_lazy_solver=False):
        self.trace_idx = trace_idx
        self.goal_call_stack = goal_call_stack
        self.symbolic_returns = None
        self.symbolic_returns_resolved = 0
        self.guide_state = guide_state
        # from object of self.state to object of guide_state
        self.heap_match = heap_match
        self.heap_match[0] = 0
        # from object of guide_state to object of self.state
        self.reverse_heap_match = reverse_heap_match
        self.reverse_heap_match[0] = 0
        self.inside_lazy_solver = inside_lazy_solver

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        th= TracerHelper(self.guide_state, self.trace_idx, self.goal_call_stack, self.heap_match.copy(), self.reverse_heap_match.copy(), inside_lazy_solver=self.inside_lazy_solver)
        th.symbolic_returns = self.symbolic_returns
        th.symbolic_returns_resolved = self.symbolic_returns_resolved
        return th

    def match_a_heap_object(self, index):
        matched = self.heap_match.get(index, None)
        if matched is not None:
            return True
        for p in self.state.abstractHeap.object_parents[index]:
            pp = self.heap_match.get(p, None)
            if pp is not None:
                matched_child = self.guide_state.abstractHeap.object_pointers[pp[0]][pp[1]]
                if matched is not None and matched != matched_child:
                    log.error("parents pointing to different object, not sure what to match")
                    return False
                else:
                    matched = matched_child
        if matched is None:
            print("No corresponding object found in guide state")
            return False
        self.heap_match[index] = matched
        self.reverse_heap_match[matched] = index
        return True

    def match_heap(self):
        todo = [0]
        done = []
        while len(todo) > 0:
            index = todo.pop(0)
            success = self.match_a_heap_object(index)
            if not success:
                log.warning("fail to match a heap object ", index)
            else:
                done.append(index)
                for offset, child in self.state.abstractHeap.object_pointers[index].items():
                    if child not in done:
                        todo.append(index)

    def match_a_heap_object_recursive(self, index):
        if self.heap_match.get(index, None) is not None:
            return True
        parents = self.state.abstractHeap.object_parents[index]
        predecessors = [index]
        while len(parents) > 0:
            if self.match_a_heap_object(parents[0][0]):
                break
            else:
                predecessors.append(parents[0][0])
                parents = self.state.abstractHeap.object_parents[parents[0][0]]
        predecessors.reverse()
        for i in predecessors:
            if not self.match_a_heap_object(i):
                log.warning("fail to match a heap object")
                return False
        return True

    def check_object_sat(self, index):
        pass

    def check_ret_value(self, ret_val):
        if self.symbolic_returns is None or len(self.symbolic_returns) <= self.symbolic_returns_resolved:
            log.error("fail to match a symbolic return")
            import IPython; IPython.embed()
            return True
        ret_info = self.symbolic_returns[self.symbolic_returns_resolved]
        self.symbolic_returns_resolved += 1
        if ret_info['type'] == 'v':
            # returns a value
            return self.check_ret_plain_value(ret_info, ret_val)
        else:
            return self.check_ret_object(ret_info, ret_val)

    def check_ret_object(self, ret_info, ret_val):
        # match heap structure
        return True

    def check_ret_plain_value(self, ret_info, ret_val):
        # transform constraints about that value
        replace_dict = {}
        replace_dict[ret_info['symbol'].cache_key] = ret_val
        related_constraints = []
        for c in ret_info['constraints']:
            add = True
            for l in c.leaf_asts():
                if l is ret_info['symbol']:
                    continue
                obj, offset = self.guide_state.abstractHeap.get_obj_offset_for_var(l)
                if obj is not None:
                    matched_obj = self.reverse_heap_match.get(obj, None)
                    if obj is not None:
                        # no corresponding object inside current state
                        add = False
                        break
                    else:
                        size = l.size()//8
                        v = self.state.abstractHeap.get_object_variable(matched_obj, offset, size)
                        replace_dict[l.cache_key] = v
            if add:
                related_constraints.append(c.replace_dict(replace_dict))
        related_constraints.extend(self.state.solver.constraints)
        self.state.solver.reload_solver(constraints=related_constraints)
        return self.state.solver.satisfiable()

    def init_symbolic_returns_info(self, ret_symbols):
        self.symbolic_returns = []
        for r in ret_symbols:
            index = self.guide_state.abstractHeap.is_symbolic_pointer(r)
            if index is None:
                # value
                info = {
                    'type': 'v',
                    'symbol': r,
                    'constraints': [],
                }
            else:
                info = {
                    'type': 'p',
                    'symbol': r,
                    'point_to': index,
                    'constraints': [],
                }
            constraints = []
            for c in self.guide_state.solver.constraints:
                for l in c.leaf_asts():
                    if l is r:
                        constraints.append(c)
                        break
            info['constraints'] = constraints
            self.symbolic_returns.append(info)
