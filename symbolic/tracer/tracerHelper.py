import angr
import logging
log = logging.getLogger("symbolic")

class TracerHelper(angr.SimStatePlugin):
    def __init__(self, guide_state, trace_idx, goal_call_stack, heap_match={}, reverse_heap_match={}, inside_lazy_solver=False):
        self.trace_idx = trace_idx
        self.goal_call_stack = goal_call_stack
        self.guide_state = guide_state
        # from object of self.state to object of guide_state
        self.heap_match = heap_match
        self.heap_match[0] = 0
        # from object of guide_state to object of self.state
        self.reverse_heap_match = reverse_heap_match
        self.reverse_heap_match[0] = 0
        self.inside_lazy_solver = inside_lazy_solver

    @angr.SimStatePlugin.memo
    def copy(self, memo):
        return TracerHelper(self.guide_state, self.trace_idx, self.goal_call_stack, self.heap_match.copy(), self.reverse_heap_match.copy(), inside_lazy_solver=self.inside_lazy_solver)

    def match_a_heap_object(self, index):
        matched = self.heap_match.get(index, None)
        if matched is not None:
            return True
        for p in self.state.abstractHeap.object_parents[index]:
            pp = self.heap_match.get(p, None)
            if pp is not None:
                matched_child = self.guide_state.abstractHeap.object_pointers[pp[0]][pp[1]]
                if matched is not None and matched != matched_child:
                    log.error("parents pointing to different object, not sure what to match")
                    return False
                else:
                    matched = matched_child
        if matched is None:
            print("No corresponding object found in guide state")
            return False
        self.heap_match[index] = matched
        self.reverse_heap_match[matched] = index
        return True

    def match_heap(self):
        todo = [0]
        done = []
        while len(todo) > 0:
            index = todo.pop(0)
            success = self.match_a_heap_object(index)
            if not success:
                log.warning("fail to match a heap object ", index)
            else:
                done.append(index)
                for offset, child in self.state.abstractHeap.object_pointers[index].items():
                    if child not in done:
                        todo.append(index)

    def match_a_heap_object_recursive(self, index):
        if self.heap_match.get(index, None) is not None:
            return True
        parents = self.state.abstractHeap.object_parents[index]
        predecessors = [index]
        while len(parents) > 0:
            if self.match_a_heap_object(parents[0][0]):
                break
            else:
                predecessors.append(parents[0][0])
                parents = self.state.abstractHeap.object_parents[parents[0][0]]
        predecessors.reverse()
        for i in predecessors:
            if not self.match_a_heap_object(i):
                log.warning("fail to match a heap object")
                return False
        return True

    def check_object_sat(self, index):
        pass

    def check_ret_value(self, ret_val):
        return True
