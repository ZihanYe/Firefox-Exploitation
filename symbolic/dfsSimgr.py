import angr
import time
import logging
import time
import sys

log = logging.getLogger("symbolic")

class DfsSimgr:
    def __init__(self, proj, initial_state, goal_state, replacing_var, ret_info, matrix, obj_start, constraints_by_var, context_end, debugger, step_limit=10000):
        self.initial_state = initial_state
        self.goal_state = goal_state
        self.replacing_var = replacing_var
        self.ret_info = ret_info
        self.to_sat_constraints = list(filter(self.related_constraints, goal_state.solver.constraints))
        self.is_returning_pointer = ret_info['type'] == 'pointer'
        self.matrix = matrix
        self.obj_start = obj_start
        self.constraints_by_var = constraints_by_var

        self.step_limit = step_limit
        self.context_end = context_end
        self.proj = proj
        self.debugger = debugger
        self.simgr = self.proj.factory.simgr(initial_state)
        count = 0
        for c in initial_state.callstack:
            count += 1
        self.goal = count - 1

        # heap info
        self.heap_map = [(self.initial_state.heap.heap_base, self.initial_state.heap.heap_base+self.initial_state.heap.heap_size)]
        for o in self.proj.loader.all_elf_objects:
            self.heap_map.append((o.min_addr, o.max_addr))


    def explore(self):
        dfs = angr.exploration_techniques.DFS(deferred_stash='deferred')
        self.simgr.use_technique(dfs)

        step = 0
        stop = False
        while not stop:
            self.simgr.step(step_func = self.step_func)
            step += 1
            stop = len(self.simgr.stashes['found']) >= 1 or len(self.simgr.stashes['active']) == 0 or len(self.simgr.stashes['primitive']) > 0 or step > self.step_limit

        if len(self.simgr.stashes['found']) >= 1:
            ret_state = self.simgr.stashes['found'][0]
            ret_val = self.simgr.stashes['found'][0].regs.rax
            # postprocess
            if not self.is_returning_pointer:
                self.goal_state.solver.constraints.append(ret_val == self.replacing_var)
            return ret_state
        else:
            return None


    def check_if_sat(self, s):
        count = 0
        for c in s.callstack:
            count += 1
        if count == self.goal and s.history.jumpkind=='Ijk_Ret':
            log.debug("[+] reach a decision point")
            # check sat
            cs = self.to_sat_constraints
            ret_val = s.regs.rax
            log.debug("[+] return with ", ret_val)
            if self.is_returning_pointer:
                # return a pointer
                success = self.check_object_match(self.ret_info, self.goal_state, s, ret_val)
            else:
                # return a value
                success = s.solver.satisfiable(extra_constraints = cs + [(self.replacing_var == ret_val)])
            if success:
                return 'SAT'
            else:
                return 'UNSAT'
        elif count > self.goal:
            return 'UNKNOWN'
        else:
            return 'UNSAT'

    def step_func(self,lsm):
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='active', to_stash='primitive')
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='unconstrained', to_stash='primitive')
        lsm.stash(filter_func=lambda s: s.addr == self.context_end, from_stash='active', to_stash='unsat')
        new_active = []
        for a in lsm.stashes['active']:
            sat = self.check_if_sat(a)
            if sat == 'SAT':
                lsm.stashes['found'] = [a]
            elif sat == 'UNSAT':
                lsm.stashes['unsat'] = [a]
            else:
                new_active.append(a)
        lsm.stashes['active'] = new_active

        for e in lsm.errored:
            success = False
            state = e.state
            try:
                msg = str(e.error)
                if msg.startswith('No bytes'):
                    index = msg.find('0x')
                    if index != -1:
                        addr = msg[index: -1]
                        success = self.debugger.resolve_address(state, int(addr, 16))
            except Exception as e:
                success = False
                print(str(e))
            if success:
                lsm.stashes['active'].append(state)
        return lsm

    def related_constraints(self, c):
        for l in c.leaf_asts():
            if l is self.replacing_var:
                return True
        return False

    def check_object_match(self, ret_info, guide_state, actual_state, actual_ptr):
        print("checking object match")
        obj_addrs = [None for o in guide_state.record.obj_mem]
        todo = [(ret_info['point_to'], actual_ptr)]
        while len(todo) >0:
            (check, addr) = todo[0]
            obj_addrs[check] = addr
            todo = todo[1:]
            for i in range(len(guide_state.record.obj_mem)):
                pointers = self.matrix[check][i]
                if len(pointers) > 0:
                    (s,p) = pointers[0]
                    offset = s - self.obj_start[check]
                    # pointer at (addr + offset)
                    t = actual_state.memory.load(addr+offset, size=8, endness=self.proj.arch.memory_endness, inspect=False)
                    # print("object ", check, " has pointer at ", addr+offset, " pointing to ", str(t))
                    # t should be address of i
                    if not isinstance(t, int) and t.uninitialized:
                        if obj_addrs[i] is None:
                            todo.append((i, t))
                        else:
                            actual_state.solver.constraints.append(t == obj_addrs[i])
                    else:
                        # t should be a valid address
                        if not self.is_valid_addr(actual_state, t):
                            return False
                        todo.append((i, t))
        index = 0
        for o in obj_addrs:
            if o is None:
                index += 1;
                continue;
            for v in guide_state.solver.all_variables:
                if str(v) not in self.constraints_by_var:
                    continue
                if str(v).find("obj_"+str(index)) != -1:
                    components = str(v).split('_')
                    offset = int(components[2])
                    size = int(components[3][:-1])
                    t = actual_state.memory.load(o+offset, size=size//self.proj.arch.byte_width, inspect=False)
                    # print("variable v:", v, " equals to content at ", o+offset, " with value ", t)
                    actual_state.solver.constraints.append(t == v)
                    # add related constraints
                    actual_state.solver.constraints.extend(self.constraints_by_var[str(v)])
            index += 1
        return actual_state.solver.satisfiable()

    def is_valid_addr(self, state, addr):
        for (lower, upper) in self.heap_map:
            if state.solver.eval(lower <= addr) and state.solver.eval(addr < upper):
                return True
        return False
