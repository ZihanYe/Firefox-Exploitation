import angr
import time
import logging
import time
import sys

log = logging.getLogger("symbolic")

class DfsSimgr:
    def __init__(self, proj, initial_state, goal_state, replacing_var, ret_info, matrix, obj_start, constraints_by_var, step_limit=10000):
        self.initial_state = initial_state
        self.goal_state = goal_state
        self.replacing_var = replacing_var
        self.ret_info = ret_info
        self.to_sat_constraints = list(filter(self.related_constraints, goal_state.solver.constraints))
        self.is_returning_pointer = ret_info['type'] == 'pointer'
        self.matrix = matrix
        self.obj_start = obj_start
        self.constraints_by_var = constraints_by_var

        self.step_limit = step_limit
        self.proj = proj
        self.simgr = self.proj.factory.simgr(initial_state)
        count = 0
        for c in initial_state.callstack:
            count += 1
        self.goal = count - 1

        # heap info
        self.heap_map = [(self.initial_state.heap.heap_base, self.initial_state.heap.heap_base+self.initial_state.heap.heap_size)]
        for o in self.proj.loader.all_elf_objects:
            self.heap_map.append((o.min_addr, o.max_addr))



    def explore(self):
        dfs = angr.exploration_techniques.DFS(deferred_stash='deferred')
        self.simgr.use_technique(dfs)

        step = 0
        stop = False
        while not stop:
            self.simgr.step(step_func = self.step_func)

            if len(self.simgr.stashes['found']) >= 1:
                stop = True
            if len(self.simgr.stashes['active']) == 0:
                stop = True
            step += 1
            if step > self.step_limit:
                stop = True

        if len(self.simgr.stashes['found']) >= 1:
            ret_state = self.simgr.stashes['found'][0]
            ret_val = self.simgr.stashes['found'][0].regs.rax
            # postprocess
            if not self.is_returning_pointer:
                self.goal_state.solver.constraints.append(ret_val == self.replacing_var)
            return ret_state
        else:
            return None


    def check_if_sat(self, s):
        count = 0
        for c in s.callstack:
            count += 1
        if count == self.goal and s.history.jumpkind=='Ijk_Ret':
            print("reach a decision point")
            # check sat
            cs = self.to_sat_constraints
            ret_val = s.regs.rax
            print("return with ", ret_val)
            if self.is_returning_pointer:
                # return a pointer
                print("ret value should be a pointer")
                import IPython; IPython.embed()
                self.check_object_match(self.ret_info, self.goal_state, s, ret_val)
            else:
                # return a value
                if s.solver.satisfiable(extra_constraints = cs + [(self.replacing_var == ret_val)]):
                    print("found a SAT return state")
                    return 'SAT'
                else:
                    print("found a UNSAT return state")
                    return 'UNSAT'
        elif count > self.goal:
            return 'UNKNOWN'
        else:
            return 'UNSAT'

    def step_func(self,lsm):
        new_active = []
        print("categorizing")
        for a in lsm.stashes['active']:
            sat = self.check_if_sat(a)
            if sat == 'SAT':
                lsm.stashes['found'] = [a]
            elif sat == 'UNSAT':
                lsm.stashes['unsat'] = [a]
            else:
                new_active.append(a)
        lsm.stashes['active'] = new_active
        print("continue with ", len(lsm.stashes['active']), " states")
        print("found ", len(lsm.stashes['found']), " sat states")
        return lsm

    def related_constraints(self, c):
        for l in c.leaf_asts():
            if l is self.replacing_var:
                return True
        return False

    def check_object_match(self, ret_info, guide_state, actual_state, actual_ptr):
        print("checking object match")
        obj_addrs = [None for o in guide_state.record.obj_mem]
        todo = [(ret_info['point_to'], actual_ptr)]
        while len(todo) >0:
            (check, addr) = todo[0]
            obj_addrs[check] = addr
            todo = todo[1:]
            for i in range(len(guide_state.record.obj_mem)):
                pointers = self.matrix[check][i]
                if len(pointers) > 0:
                    (s,p) = pointers[0]
                    offset = s - self.obj_start[check]
                    # pointer at (addr + offset)
                    t = actual_state.memory.load(addr+offset, size=8, inspect=False)
                    print("object ", check, " has pointer at ", addr+offset, " pointing to ", str(t))
                    # t should be address of i
                    if not isinstance(t, int) and t.uninitialized:
                        if obj_addrs[i] is None:
                            # new an object
                            # start_addr = actual_state.memory.state.heap._malloc(0x700)
                            # end_addr = start_addr + 0x700
                            # actual_state.record.add_obj_mem((start_addr, end_addr))
                            # actual_state.solver.constraints.append(t == start_addr)
                            todo.append((i, t))
                        else:
                            actual_state.solver.constraints.append(t == obj_addrs[i])
                    else:
                        # t should be a valid address
                        if not self.is_valid_addr(actual_state, t):
                            return False
                        todo.append((i, t))
        import IPython; IPython.embed()
        index = 0
        for o in obj_addrs:
            if o is None:
                index += 1;
                continue;
            for v in guide_state.solver.all_variables:
                if str(v).find("obj_"+str(index)) != -1:
                    components = str(v).split('_')
                    offset = int(components[2])
                    size = int(components[3][:-1])
                    t = actual_state.memory.load(o+offset, size=size//self.proj.arch.byte_width, inspect=False)
                    print("variable v:", v, " equals to content at ", o+offset, " with value ", t)
                    actual_state.solver.constraints.append(t == v)
                    # add related constraints
                    actual_state.solver.constraints.extend(self.constraints_by_var[str(v)])
            index += 1
        import IPython; IPython.embed()
        return actual_state.solver.satisfiable()

    def is_valid_addr(self, state, addr):
        for (lower, upper) in self.heap_map:
            if state.solver.eval(lower <= addr) and state.solver.eval(addr < upper):
                return True
        return False
