import angr
import time
import logging
import time
import sys

log = logging.getLogger("symbolic")

class DfsSimgr:
    def __init__(self, proj, initial_state, goal_state, replacing_var, ret_info, step_limit=10000):
        self.initial_state = initial_state
        self.goal_state = goal_state
        self.replacing_var = replacing_var
        self.ret_info = ret_info
        self.to_sat_constraints = list(filter(self.related_constraints, goal_state.solver.constraints))
        self.is_returning_pointer = ret_info['type'] == 'pointer'
        self.step_limit = step_limit
        self.proj = proj
        self.simgr = self.proj.factory.simgr(initial_state)
        count = 0
        for c in initial_state.callstack:
            count += 1
        self.goal = count - 1


    def explore(self):
        dfs = angr.exploration_techniques.DFS(deferred_stash='deferred')
        self.simgr.use_technique(dfs)

        step = 0
        stop = False
        while not stop:
            self.simgr.step(step_func = self.step_func)

            if len(self.simgr.stashes['found']) >= 1:
                stop = True
            if len(self.simgr.stashes['active']) == 0:
                stop = True
            step += 1
            if step > self.step_limit:
                stop = True

        if len(self.simgr.stashes['found']) >= 1:
            ret_state = self.simgr.stashes['found'][0]
            ret_val = self.simgr.stashes['found'][0].regs.rax
            # postprocess
            if not self.is_returning_pointer:
                self.goal_state.solver.constraints.append(ret_val == self.replacing_var)
            return ret_state
        else:
            return None


    def check_if_sat(self, s):
        count = 0
        for c in s.callstack:
            count += 1
        if count == self.goal and s.history.jumpkind=='Ijk_Ret':
            print("reach a decision point")
            # check sat
            cs = self.to_sat_constraints
            ret_val = s.regs.rax
            print("return with ", ret_val)
            if self.is_returning_pointer:
                # return a pointer
                print("ret value should be a pointer")
                import IPython; IPython.embed()
            else:
                # return a value
                if s.solver.satisfiable(extra_constraints = cs + [(self.replacing_var == ret_val)]):
                    print("found a SAT return state")
                    return 'SAT'
                else:
                    print("found a UNSAT return state")
                    return 'UNSAT'
        elif count > self.goal:
            return 'UNKNOWN'
        else:
            return 'UNSAT'

    def step_func(self,lsm):
        new_active = []
        print("categorizing")
        for a in lsm.stashes['active']:
            sat = self.check_if_sat(a)
            if sat == 'SAT':
                lsm.stashes['found'] = [a]
            elif sat == 'UNSAT':
                lsm.stashes['unsat'] = [a]
            else:
                new_active.append(a)
        lsm.stashes['active'] = new_active
        print("continue with ", len(lsm.stashes['active']), " states")
        print("found ", len(lsm.stashes['found']), " sat states")
        return lsm

    def related_constraints(self, c):
        for l in c.leaf_asts():
            if l is self.replacing_var:
                return True
        return False

    def check_object_match(self, guide_state, guide_obj, actual_state, actual_obj):
        pass

    def dummy_func(self, state):
        print("dummy called")
        pass
