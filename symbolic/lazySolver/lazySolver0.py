from ..analyse.stateAnalyse import StateAnalyse
import abstractHeapLayout
import heapObject

class LazySolver:
    def __init__(self, proj, goal_state, uaf_object_base, uaf_object_size):
        self.proj = proj
        self.goal_state = goal_state
        # return values that has constraints
        self.constrained_return_value = []
        self.return_vars = []
        self.heap = abstractHeapLayout.AbstractHeapLayout(goal_state)
        self.__analyse_returns()


    def solve_one_checkpoint(self, check_state, heap, guide_state):
        check_state.checkpoint.exploring = True
        check_state.__add_instrumentation()
        depth = 0
        for c in check_state.callstack:
            depth += 1
        check_state.checkpoint.finish_goal = depth-1
        simgr.proj.factory.simgr(check_state)


    def check_sat(self, s):
        count = 0
        for c in s.callstack:
            count += 1
        if count == s.checkpoint.finish_goal and s.history.jumpkind=='Ijk_Ret':
            log.debug("[+] reach a decision point")
            # check if sat or not


    def merge(self, heap, guide_state, state, ret_symbol, interesting_constraints):
        heap_to_match = abstractHeapLayout.AbstractHeapLayout(state, interesting_constraints=interesting_constraints)
        match_map = {} # map object in heap_to_match to heap
        # root object always match
        init_match_map[0] = 0
        work_list = [0]
        for (s1, obj1) in heap_to_match.symbolic_return_point_to:
            for (s2, obj2) in heap.symbolic_return_point_to:
                if s1 is s2:
                    match_map[obj1] = obj2
                    work_list.append(obj1)
                    break
        match_map = self.__merge_heap(heap, guide_state, heap_to_match, init_match_map, work_list)
        # check return value
        ret_val = state.regs.rax
        returned_obj = state.record.check_inside_obj_index(ret_val)
        if returned_obj is not None:
            ret_match_map = {}
            ret_match_map[returned_obj] = match_map[returned_obj]
            for (s, o) in heap.symbolic_return_point_to:
                if s is ret_symbol:
                    ret_obj_ind = o
                    break
            self.__merge_heap(heap, guide_state, heap, ret_match_map, [ret_obj_ind])
        else:
            # return a value: replace ret_symbol with ret_val
            returned_val = heap.convert_to_concrete(ret_val, index_match=match_map)
            guide_state.solver.constraints.append(returned_val == ret_symbol)


    def __merge_heap(self, heap, guide_state, heap_to_match, match_map, work_list):
        done = []
        while len(work_list) > 0:
            ind_to_match = work_list.pop(0)
            obj_to_match = heap_to_match.objects[ind_to_match]
            ind = match_map[ind_to_match]
            obj = heap.objects.get(ind, None)
            if obj is None:
                done.append(ind_to_match)
                continue
            cs = []
            newvs = []
            # match constraint
            for (offx, x, sx) in obj_to_match.variables:
                addr = guide_state.record.obj_mem[obj][0] + offx
                v = guide_state.memory.load(addr, size=sx, inspect=False)
                cs.append(v == x)
                newv.append(x)

            guide_state.solver.constraints.extend(cs)
            guide_state.solver.constraints.extend(obj_to_match.constraints)

            # match pointers
            for off, p in obj_to_match.pointers.items(): # pointer at offset off
                p_matched = obj.pointers.get(off, None) # (id, offset) of corresponding pointer in obj
                if p_matched is not None:
                    match_map[p[0]] = p_matched[0] # !!!
                    if p[0] not in done:
                        work_list.append(p[0])
                else:
                    # create a new object
                    pointer_addr = guide_state.record.obj_mem[obj][0] + off
                    addr = guide_state.memory.load(pointer_addr, size=8, endness=self.proj.arch.memory_endness, inspect=False)
                    v = guide_state.memory.load(addr, size = 1, inspect=False)
                    i = guide_state.record.check_inside_obj_index(v)
                    # update associated heap
                    if heap.objects.get(i, None) == None:
                        heap.objects[i] = heapObject.HeapObject(i)
                        heap.objects[ind].pointers[off] = (i, 0)

                    match_map[p[0]] = i
                    if p[0] not in done:
                        work_list.append(p[0])
            done.append(ind_to_match)
        return match_map


    def __match_object_variables(self, heap, guide_state, index, obj_to_match):
        obj = heap.objects.get(ind, None)
        if obj is None:
            return
        cs = []
        newvs = []
        # match constraint
        for (offx, x, sx) in obj_to_match.variables:
            addr = guide_state.record.obj_mem[obj][0] + offx
            v = guide_state.memory.load(addr, size=sx, inspect=False)
            cs.append(v == x)
            newv.append(x)
        guide_state.solver.constraints.extend(cs)
        guide_state.solver.constraints.extend(obj_to_match.constraints)

    def __state_contains_var(self, state, var):
        if var == None:
            return False
        for v in state.solver.all_variables:
            if v is var:
                return True
        return False

    def __analyse_returns(self):
        for symbol in self.goal_state.checkpoint.ret_vars:
            for c in self.goal_state.solver.constraints:
                found = False
                for l in c.leaf_asts():
                    if l is var:
                        self.constrained_return_value.append(symbol)
                        found = True
                        break;
                if found:
                    break;

            obj_idx = self.goal_state.record.check_inside_obj_index(symbol)
            if obj_idx is not None: # returns a pointer
                c = {
                    'symbol': symbol,
                    'type': 'pointer',
                    'point_to': obj_idx,
                }
                self.objects[obj_idx] = symbol
            else:
                # a value or unused
                c = { 'symbol': symbol, 'type': 'value' }
            self.return_vars.append(c)

    def __add_instrumentation(self, state):
        state.inspect.b('constraints', when=BP_AFTER, action=self.track_constraints)

    def track_constraints(self,state):
        if state.checkpoint.exploring:
            state.checkpoint.constraints_for_self.append(state.inspect.added_constraints)
