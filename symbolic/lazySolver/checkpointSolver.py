import angr
from . import abstractHeapLayout
import logging
log = logging.getLogger("symbolic")

class CheckpointSolver:
    def __init__(self, proj, initial_state, ret_symbol, goal_state, heap, debugger, step_limit=1000, type='up'):
        self.proj = proj
        self.debugger = debugger
        self.guide_state = goal_state
        self.initial_state = initial_state
        self.ret_symbol = ret_symbol
        self.guide_heap = heap
        self.step_limit = step_limit

    def solve(self):
        self.initial_state.checkpoint.exploring = True
        self.__add_instrumentation(self.initial_state)
        depth = 0
        for c in self.initial_state.callstack:
            depth += 1
        self.initial_state.checkpoint.finish_goal = depth-1
        self.simgr = self.proj.factory.simgr(self.initial_state)
        return self.explore()

    def explore(self):
        dfs = angr.exploration_techniques.DFS(deferred_stash='deferred')
        self.simgr.use_technique(dfs)

        self.solutions = []
        step = 0
        stop = False
        while not stop:
            self.simgr.step(step_func = self.step_func)
            step += 1
            stop = len(self.simgr.stashes['found']) >= 1 or len(self.simgr.stashes['active']) == 0 or step > self.step_limit
        return self.solutions

    def check_sat(self, s):
        count = 0
        for c in s.callstack:
            count += 1
        if count == s.checkpoint.finish_goal and s.history.jumpkind=='Ijk_Ret':
            log.debug("[+] reach a decision point")
            # check if sat or not
            success, guide_state, guide_heap = self.merge(s, self.ret_symbol, s.checkpoint.constraints_for_self)
            if success and guide_state.solver.satisfiable():
                # sat
                print('find one SAT state!! checkpoint solved')
                return 'SAT', guide_state, guide_heap
            else:
                return 'UNSAT', None, None
        elif count > s.checkpoint.finish_goal:
            return 'UNKNOWN', None, None
        else:
            return 'UNSAT', None, None

    def step_func(self, lsm):
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='active', to_stash='primitive')
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='unconstrained', to_stash='primitive')
        new_active = []
        for a in lsm.stashes['active']:
            sat, new_state, new_heap = self.check_sat(a)
            if sat == 'SAT':
                lsm.stashes['found'] = [a]
                self.solutions.append((new_state, new_heap))
            elif sat == 'UNSAT':
                lsm.stashes['unsat'] = [a]
            else:
                new_active.append(a)
        lsm.stashes['active'] = new_active

        for e in lsm.errored:
            success = False
            state = e.state
            try:
                msg = str(e.error)
                if msg.startswith('No bytes'):
                    index = msg.find('0x')
                    if index != -1:
                        addr = msg[index: -1]
                        success = self.debugger.resolve_address(state, int(addr, 16))
            except Exception as e:
                success = False
                print(str(e))
            if success:
                lsm.stashes['active'].append(state)
        return lsm

    def merge(self, state, ret_symbol, interesting_constraints):
        heap = self.guide_heap.copy()
        guide_state = self.guide_state.copy()
        final_constraints = guide_state.solver.constraints

        heap_to_match = abstractHeapLayout.AbstractHeapLayout(state)
        heap_to_match.initialize()
        init_match_map = {} # map object in heap_to_match to heap
        # root object always match
        init_match_map[0] = 0
        work_list = [0]
        for (s1, obj1) in heap_to_match.symbolic_return_point_to:
            for (s2, obj2) in heap.symbolic_return_point_to:
                if s1 is s2:
                    init_match_map[obj1] = obj2
                    work_list.append(obj1)
                    break
        success, match_map = self.__merge_heap(heap, guide_state, heap_to_match, init_match_map, work_list)
        if not success:
            return False, None, None
        final_constraints = self.__filter_constraints(final_constraints, guide_state)
        more_constraints = self.__match_constraints(heap, guide_state, heap_to_match, state, match_map, interesting_constraints)
        final_constraints.extend(more_constraints)
        # print(guide_state.solver.constraints)
        # print("merge return value")
        # import IPython; IPython.embed()

        # check return value
        ret_val = state.regs.rax
        returned_obj = state.record.check_inside_obj_index(ret_val)
        if returned_obj is not None:
            ret_match_map = {}
            ret_obj_ind = None
            for (s, o) in heap.symbolic_return_point_to:
                if s is ret_symbol:
                    ret_obj_ind = o
                    break
            if ret_obj_ind is not None and ret_obj_ind in match_map:
                ret_match_map[ret_obj_ind] = match_map[returned_obj]
                success, match_map = self.__merge_heap(heap, guide_state, heap, ret_match_map, [ret_obj_ind])
                if not success:
                    return False, None, None
                replacing_vars = self.__merge_variables(heap, guide_state, heap, guide_state, match_map)
                final_constraints = self.__replace_all(final_constraints, replacing_vars)
        else:
            # return a value: replace ret_symbol with ret_val
            returned_val = self.__convert_asts(heap, guide_state, heap_to_match, state, match_map, [ret_val])[0]
            final_constraints.append(returned_val == ret_symbol)
        guide_state.solver.reload_solver(constraints=final_constraints)
        print("done merging")
        import IPython; IPython.embed()
        return True, guide_state, heap


    def __merge_heap(self, heap, guide_state, heap_to_match, match_map, work_list):
        done = []
        while len(work_list) > 0:
            ind_to_match = work_list.pop(0)
            obj_to_match = heap_to_match.objects[ind_to_match]
            ind = match_map[ind_to_match]
            obj = heap.objects.get(ind, None)
            if obj is None:
                done.append(ind_to_match)
                continue

            # match pointers
            for off, p in obj_to_match.pointers.items(): # pointer at offset off
                p_matched = obj.pointers.get(off, None) # (id, offset) of corresponding pointer in obj
                if p_matched is not None:
                    match_map[p[0]] = p_matched[0] # !!!
                    if p[0] not in done:
                        work_list.append(p[0])
                else:
                    # create a new object
                    pointer_addr = guide_state.record.obj_mem[obj][0] + off
                    addr = guide_state.memory.load(pointer_addr, size=8, endness=self.proj.arch.memory_endness, inspect=False)
                    if not isinstance(addr, int) and addr.uninitialized:
                        v = guide_state.memory.load(addr, size = 1, inspect=False)
                        i = guide_state.record.check_inside_obj_index(v)
                        heap.add_an_object(i, ind, off, guide_state.solver.eval_one(addr))
                    else:
                        return False, matched_map

                    match_map[p[0]] = i
                    if p[0] not in done:
                        work_list.append(p[0])
            done.append(ind_to_match)
        print("merged heap")
        import IPython; IPython.embed()
        return True, match_map

    def __filter_constraints(self, constraints, state):
        cs = []
        for c in constraints:
            if c.op == '__eq__':
                if (isinstance(c.args[0],int) or c.args[0].concrete) and state.record.check_inside_obj(c.args[0]):
                    continue
                if (isinstance(c.args[1],int) or c.args[1].concrete) and state.record.check_inside_obj(c.args[1]):
                    continue
            cs.append(c)
        return cs


    def __match_constraints(self, heap, guide_state, heap_to_match, state, match_map, interesting_constraints):
        good_constraints = self.__filter_constraints(interesting_constraints, state)

        new_constraints = self.__convert_asts(heap, guide_state, heap_to_match, state, match_map, good_constraints)
        # guide_state.solver.constraints.extend(new_constraints)
        # import IPython; IPython.embed()
        return new_constraints

    def __convert_asts(self, heap, guide_state, heap_to_match, state, match_map, asts):
        varnames = frozenset()
        for a in asts:
            varnames = varnames.union(a.variables)
        replacing_dict = {}
        for v in state.solver.all_variables:
            if list(v.variables)[0] in varnames:
                addr = None
                size = v.size()
                addr = state.record.get_addr_for_var(v)
                if addr is not None:
                    index = state.record.check_inside_obj_index(addr)
                    if index is not None:
                        offset = addr - heap_to_match.obj_start[index]
                        if index not in match_map:
                            print("[-] error object is not matched")
                            import IPython; IPython.embed()
                            continue
                        real_addr = heap.obj_start[match_map[index]] + offset
                        real_v = guide_state.memory.load(real_addr, size=size//self.proj.arch.byte_width,inspect=False)
                        replacing_dict[v.cache_key] = real_v

        return self.__replace_all(asts, replacing_dict)

    def __replace_all(self, asts, replacing_dict):
        new_asts = []
        for a in asts:
            new_asts.append(a.replace_dict(replacing_dict))
        return new_asts

    def __merge_variables(self, heap, guide_state, heap_to_match, state, match_map):
        replacing_dict = {}
        for a,b in match_map.items():
            for (off,v) in heap_to_match.objects[a].variables:
                size = v.size()
                real_addr = heap.obj_start[b] + off
                real_v = guide_state.memory.load(real_addr, size=size//self.proj.arch.byte_width,inspect=False)
                replacing_dict[v.cache_key] = real_v
        return replacing_dict

    def __match_concrete(self, cv, state, heap, obj_to_match):
        obj_addr = {}
        obj_addr[obj_to_match] = cv
        todo = [obj_to_match]
        while len(todo) > 0:
            i = todo.pop(0)
            for (off,v) in heap.objects[i].variables:
                size = v.size()
                real_addr = obj_addr[i] + off
                real_v = state.memory.load(real_addr, size=size//self.proj.arch.byte_width,inspect=False)
                # TODO:



    def __add_instrumentation(self, state):
        state.inspect.b('constraints', when=angr.BP_AFTER, action=self.track_constraints)

    def track_constraints(self,state):
        if state.checkpoint.exploring:
            state.checkpoint.constraints_for_self.extend(state.inspect.added_constraints)
