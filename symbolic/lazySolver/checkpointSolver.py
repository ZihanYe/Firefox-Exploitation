import angr
from . import abstractHeapLayout

class CheckpointSolver:
    def __init__(self, proj, initial_state, goal_state, heap, debugger, type='up'):
        self.proj = proj
        self.debugger = debugger
        self.guide_state = goal_state
        self.initial_state = initial_state
        self.guide_heap = heap

    def solve(self):
        self.initial_state.checkpoint.exploring = True
        self.__add_instrumentation(self.initial_state)
        depth = 0
        for c in self.initial_state.callstack:
            depth += 1
        self.initial_state.checkpoint.finish_goal = depth-1
        self.simgr = self.proj.factory.simgr(self.initial_state)
        return self.explore()

    def explore(self):
        dfs = angr.exploration_techniques.DFS(deferred_stash='deferred')
        self.simgr.use_technique(dfs)

        self.solutions = []
        step = 0
        stop = False
        while not stop:
            self.simgr.step(step_func = self.step_func)
            step += 1
            stop = len(self.simgr.stashes['found']) >= 1 or len(self.simgr.stashes['active']) == 0 or step > self.step_limit
        return self.solutions

    def check_sat(self, s):
        count = 0
        for c in s.callstack:
            count += 1
        if count == s.checkpoint.finish_goal and s.history.jumpkind=='Ijk_Ret':
            log.debug("[+] reach a decision point")
            # check if sat or not
            guide_heap = self.guide_heap.copy()
            guide_state = self.guide_state.copy()
            self.merge(guide_heap, guide_state, s, s.checkpoint.ret_symbol, s.checkpoint.constraints_for_self)
            if guide_state.solver.satisfiable():
                # sat
                return 'SAT', guide_heap, guide_state
            else:
                return 'UNSAT', None, None
        elif count > s.checkpoint.finish_goal:
            return 'UNKNOWN', None, None
        else:
            return 'UNSAT', None, None

    def step_func(self, lsm):
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='active', to_stash='primitive')
        lsm.stash(filter_func=lambda s: s.record.primitive is not None, from_stash='unconstrained', to_stash='primitive')
        lsm.stash(filter_func=lambda s: s.addr == self.context_end, from_stash='active', to_stash='unsat')
        new_active = []
        for a in lsm.stashes['active']:
            sat, new_state, new_heap = self.check_sat(a)
            if sat == 'SAT':
                lsm.stashes['found'] = [a]
                self.solutions.append((new_state, new_heap))
            elif sat == 'UNSAT':
                lsm.stashes['unsat'] = [a]
            else:
                new_active.append(a)
        lsm.stashes['active'] = new_active

        for e in lsm.errored:
            success = False
            state = e.state
            try:
                msg = str(e.error)
                if msg.startswith('No bytes'):
                    index = msg.find('0x')
                    if index != -1:
                        addr = msg[index: -1]
                        success = self.debugger.resolve_address(state, int(addr, 16))
            except Exception as e:
                success = False
                print(str(e))
            if success:
                lsm.stashes['active'].append(state)
        return lsm

    def merge(self, heap, guide_state, state, ret_symbol, interesting_constraints):
        heap_to_match = abstractHeapLayout.AbstractHeapLayout(state)
        heap_to_match.initialize()
        match_map = {} # map object in heap_to_match to heap
        # root object always match
        init_match_map[0] = 0
        work_list = [0]
        for (s1, obj1) in heap_to_match.symbolic_return_point_to:
            for (s2, obj2) in heap.symbolic_return_point_to:
                if s1 is s2:
                    match_map[obj1] = obj2
                    work_list.append(obj1)
                    break
        match_map = self.__merge_heap(heap, guide_state, heap_to_match, init_match_map, work_list)
        self.__match_constraints(heap, guide_state, heap_to_match, match_map, interesting_constraints)

        print("merge return value")
        import IPython; IPython.embed()

        # check return value
        ret_val = state.regs.rax
        returned_obj = state.record.check_inside_obj_index(ret_val)
        if returned_obj is not None:
            ret_match_map = {}
            for (s, o) in heap.symbolic_return_point_to:
                if s is ret_symbol:
                    ret_obj_ind = o
                    break
            ret_match_map[ret_obj_ind] = match_map[returned_obj]
            self.__merge_heap(heap, guide_state, heap, ret_match_map, [ret_obj_ind])
        else:
            # return a value: replace ret_symbol with ret_val
            returned_val = self.__convert_asts(heap, guide_state, heap_to_match, state, match_map, [ret_val])[0]
            guide_state.solver.constraints.append(returned_val == ret_symbol)
        print("done merging")
        import IPython; IPython.embed()


    def __merge_heap(self, heap, guide_state, heap_to_match, match_map, work_list):
        done = []
        while len(work_list) > 0:
            ind_to_match = work_list.pop(0)
            obj_to_match = heap_to_match.objects[ind_to_match]
            ind = match_map[ind_to_match]
            obj = heap.objects.get(ind, None)
            if obj is None:
                done.append(ind_to_match)
                continue

            # match pointers
            for off, p in obj_to_match.pointers.items(): # pointer at offset off
                p_matched = obj.pointers.get(off, None) # (id, offset) of corresponding pointer in obj
                if p_matched is not None:
                    match_map[p[0]] = p_matched[0] # !!!
                    if p[0] not in done:
                        work_list.append(p[0])
                else:
                    # create a new object
                    pointer_addr = guide_state.record.obj_mem[obj][0] + off
                    addr = guide_state.memory.load(pointer_addr, size=8, endness=self.proj.arch.memory_endness, inspect=False)
                    v = guide_state.memory.load(addr, size = 1, inspect=False)
                    i = guide_state.record.check_inside_obj_index(v)
                    heap.add_an_object(i, ind, off, guide_state.solver.eval_one(addr))

                    match_map[p[0]] = i
                    if p[0] not in done:
                        work_list.append(p[0])
            done.append(ind_to_match)
        import IPython; IPython.embed()
        return match_map

    def __match_constraints(self, heap, guide_state, heap_to_match, state, match_map, interesting_constraints):
        good_constraints = []
        for c in interesting_constraints:
            if c.op == '__eq__':
                if (isinstance(c.args[0],int) or c.args[0].concrete) and state.record.check_inside_obj(c.args[0]):
                    continue
                if (isinstance(c.args[1],int) or c.args[1].concrete) and state.record.check_inside_obj(c.args[1]):
                    continue
            good_constraints.append(c)

        new_constraints = self.__convert_asts(heap, guide_state, heap_to_match, state, math_map, good_constraints)
        guide_state.solver.constraints.extend(new_constraints)

    def __convert_asts(self, heap, guide_state, heap_to_match, state, match_map, asts):
        varnames = frozenset()
        for a in asts:
            varnames = varnames.union(a.variables)
        replacing_dict = {}
        for v in state.solver.all_variables:
            if list(v.variables)[0] in varnames:
                addr = None
                size = v.size()
                addr = state.record.get_addr_for_var(v)
                if addr is not None:
                    index = state.record.check_inside_obj_index(addr)
                    if index is not None:
                        offset = addr - heap_to_match.obj_start[index]
                        if index not in match_map:
                            print("[-] error object is not matched")
                            import IPython; IPython.embed()
                            continue
                        real_addr = heap.obj_start[match_map[index]] + offset
                        real_v = guide_state.memory.load(real_addr, size=size,inspect=False)
                        replacing_dict[v.cache_key] = real_v

        new_asts = []
        for a in asts:
            new_asts.append(a.replace_dict(replacing_dict))
        return new_asts

    def __add_instrumentation(self, state):
        state.inspect.b('constraints', when=angr.BP_AFTER, action=self.track_constraints)

    def track_constraints(self,state):
        if state.checkpoint.exploring:
            state.checkpoint.constraints_for_self.append(state.inspect.added_constraints)
