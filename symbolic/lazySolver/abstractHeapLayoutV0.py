import heapObject

class AbstractHeapLayout:
    def __init__(self, state, name, interesting_constraints= None, additional_variables=None):
        self.name = name
        self.state = state
        self.obj_mem = self.state.record.obj_mem
        self.n = len(self.obj_mem)
        self.interesting_constraints = interesting_constraints if interesting_constraints is not None else self.state.solver.constraints
        if interesting_constraints == None:
            self.interesting_variables = self.state.solver.all_variables
        else:
            self.interesting_variables = []
            varnames = frozenset()
            for c in self.interesting_constraints:
                varnames = varnames.union(c.variables)
            if additional_variables is not None
                varnames = varnames.union(additional_variables)
            for v in self.state.solver.all_variables:
                if list(v.variables)[0] in varnames:
                    self.interesting_variables.append(v)

        self.objects = {}
        i = 0
        for o in self.obj_mem:
            self.objects[i] = heapObject.HeapObject(i)
            i += 1

        self.matrix = []
        self.symbolic_return_point_to = []
        self.__get_obj_relation()
        self.obj_start = []
        for i in range(self.n):
            self.obj_start.append(self.__possible_start(i))

        self.__build_tree()
        self.constraints = []
        self.variables = []
        self.replace_dict = {}
        self.__trainsform_constraints()
        # self.__cateogrise_constraints()

    def copy(self):
        pass

    def replace_ast(self, ast):
        return ast.replace_dict(self.replace_dict)

    def convert_to_concrete(self, ast, index_match=None):
        concrete_map = {}
        for l in ast.leaf_asts():
            if "obj_" in str(l):
                components = str(l).split('_')
                index = components[2]
                offset = components[3]
                size = components[4]
                if index_match is not None:
                    index = index_match.get(index, index)
                addr = self.state.obj_mem[index][0] + offset
                v = self.state.memory.load(addr, size=size, inspect=False)
                concrete_map[l.cache_key] = v
        return ast.replace_dict(concrete_map)


    def __build_tree(self):
        for i in range(self.n):
            for j in range(self.n):
                for (s,p) in self.matrix[i][j]:
                    offset_i = s - self.obj_start[i]
                    offset_j = p - self.obj_start[j]
                    self.objects[i].pointers[offset_i] = (j, offset_j)
                    self.objects[j].parents.append((i, offset_i))

    def __trainsform_constraints(self):
        # transform constraints of goal_state to memory independent
        self.variables = []
        new_constraints = []
        for c in self.interesting_constraints:
            if c.op == '__eq__':
                if (isinstance(c.args[0],int) or c.args[0].concrete) and self.state.record.check_inside_obj(c.args[0]):
                    continue
                if (isinstance(c.args[1],int) or c.args[1].concrete) and self.state.record.check_inside_obj(c.args[1]):
                    continue
            new_constraints.append(c)

        for v in self.interesting_variables:
            addr = None
            size = v.size()
            addr = self.state.record.get_addr_for_var(v)
            if addr is not None:
                index = self.state.record.check_inside_obj_index(addr)
                if index is not None:
                    # variable_set.append(v)
                    offset = addr - self.obj_start[index]
                    newv = self.state.solver.BVS("obj_"+self.name+"_"+str(index)+"_"+str(offset)+"_"+str(size), size = size, explicit_name=True)
                    # for i in range(len(self.constraints)):
                    #     self.constraints[i] = self.constraints[i].replace(v, newv)
                    self.replace_dict[v.cache_key] = newv
                    self.variables.append(newv)
                    self.objects[index].variables.append((offset, newv, size))
                else:
                    self.variables.append(v)
            else:
                self.variables.append(v)
        for c in new_constraints:
            self.constraints.append(c.replace_dict(self.replace_dict))

        # replace
        # self.goal_state.solver.reload_solver(constraints=new_constraints)
        # self.goal_state.solver.all_variables = new_variables

    def __cateogrise_constraints(self):
        for c in self.constraints:
            vars = c.variables
            for i in range(self.n)
                for (off, var, size) in self.objects[i].variables:
                    if var.variables[0] in vars:
                        self.objects[i].constraints.append(c)
                        break



    def __get_obj_relation(self):
        for (s,p) in self.state.record.symbolic_pointers:
            pointed_by = None
            for i in range(self.n):
                if s >= self.obj_mem[i][0] and s < self.obj_mem[i][1]:
                    pointed_by = i
                    break

            point_to = None
            for i in range(self.n):
                if p >= self.obj_mem[i][0] and p < self.obj_mem[i][1]:
                    point_to = i
                    break

            if pointed_by is not None and point_to is not None:
                self.matrix[pointed_by][point_to].append((s,p))

        for (var, s) in self.state.checkpoints:
            idx = self.state.record.check_inside_obj_index(var)
            if idx is not None:
                self.symbolic_return_point_to.append((var, idx))

    def __possible_start(self, index):
        if index == 0:
            # it is the uaf (root) object
            return self.obj_mem[index][0]

        start = self.obj_mem[index][1]
        found = False
        for i in range(len(self.obj_mem)):
            for (s,p) in self.matrix[i][index]:
                if p < start:
                    # possible base address
                    start = p
                    found = True
        for (v, a) in self.vars_in_objs[index]:
            # a = min(addrs)
            if a < start:
                start = a
                found = True

        for (v, idx) in self.symbolic_return_point_to:
            if idx == index and self.state.solver.eval(v < start):
                try:
                    start = self.state.solver.eval_one(v)
                    found = True
                except:
                    log.error("[-] exception in evaluating a pointer")
        if not found:
            start = self.obj_mem[index][0]
        return start
