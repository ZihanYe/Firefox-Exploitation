import heapObject

class AbstractHeapLayout:
    def __init__(self, state, objects={}, obj_start=[], symbolic_return_point_to=[]):
        self.state = state
        self.objects = objects
        self.obj_start = obj_start
        self.symbolic_return_point_to = symbolic_return_point_to

    def copy(self):
        return AbstractHeapLayout(self.state.copy(), self.objects.copy(), self.obj_start.copy(), self.symbolic_return_point_to.copy())

    def add_an_object(self, id, pointed_by, offset, obj_start):
        if heap.objects.get(id, None) == None:
            self.objects[id] = heapObject.HeapObject(id)
            self.objects[pointed_by].pointers[offset] = (id, 0)
            self.obj_start[id] = obj_start

    def initialize(self):
        i = 0
        for o in self.state.record.obj_mem:
            self.objects[i] = heapObject.HeapObject(i)
            i += 1

        self.matrix = []
        self.__get_obj_relation()
        self.vars_in_objs = []
        self.__variable_map()
        for i in range(self.n):
            self.obj_start.append(self.__possible_start(i))
        self.__build_tree()

    def __build_tree(self):
        for i in range(self.n):
            for j in range(self.n):
                for (s,p) in self.matrix[i][j]:
                    offset_i = s - self.obj_start[i]
                    offset_j = p - self.obj_start[j]
                    self.objects[i].pointers[offset_i] = (j, offset_j)

    def __get_obj_relation(self):
        n = len(self.state.record.obj_mem)
        for (s,p) in self.state.record.symbolic_pointers:
            pointed_by = None
            for i in range(n):
                if s >= self.state.record.obj_mem[i][0] and s < self.state.record.obj_mem[i][1]:
                    pointed_by = i
                    break

            point_to = None
            for i in range(n):
                if p >= self.state.record.obj_mem[i][0] and p < self.state.record.obj_mem[i][1]:
                    point_to = i
                    break

            if pointed_by is not None and point_to is not None:
                self.matrix[pointed_by][point_to].append((s,p))

        for (var, s) in self.state.checkpoint.ret_vars:
            idx = self.state.record.check_inside_obj_index(var)
            if idx is not None:
                self.symbolic_return_point_to.append((var, idx))

    def __possible_start(self, index):
        if index == 0:
            # it is the uaf (root) object
            return self.state.record.obj_mem[index][0]

        start = self.state.record.obj_mem[index][1]
        found = False
        for i in range(len(self.state.record.obj_mem)):
            for (s,p) in self.matrix[i][index]:
                if p < start:
                    # possible base address
                    start = p
                    found = True
        for (v, a) in self.vars_in_objs[index]:
            # a = min(addrs)
            if a < start:
                start = a
                found = True

        for (v, idx) in self.symbolic_return_point_to:
            if idx == index and self.state.solver.eval(v < start):
                try:
                    start = self.state.solver.eval_one(v)
                    found = True
                except:
                    log.error("[-] exception in evaluating a pointer")
        if not found:
            start = self.state.record.obj_mem[index][0]
        return start

    def __variable_map(self):
        self.vars_in_objs = [[] for i in range(len(self.state.record.obj_mem))]
        for v in self.state.solver.all_variables:
            addr = self.state.record.get_addr_for_var(v)
            if addr is not None:
                index = self.state.record.check_inside_obj_index(addr)
                if index is not None:
                    self.vars_in_objs[index].append((v, addr))
