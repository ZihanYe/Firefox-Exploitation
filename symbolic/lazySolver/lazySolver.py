import abstractHeapLayout
import checkpointSolver

class LazySolver:
    def __init__(self, proj, goal_state, debugger):
        self.proj = proj
        self.debugger = debugger
        self.goal_state = goal_state
        self.heap = abstractHeapLayout.AbstractHeapLayout(goal_state)
        self.heap.initialize()
        print("done initializing")
        import IPython; IPython.embed()
        # return values that has constraints
        # self.constrained_return_value = []
        # self.return_vars = []
        # self.__analyse_returns()


    def solve_checkpoints(self, try_limit=10):
        heap = self.heap
        guide_state = self.goal_state
        last_check_state = self.goal_state.checkpoint.checkstate
        check_state = self.goal_state.checkpoint.checkstate
        trial = 0
        # up
        while check_state is not None and trial < try_limit:
            print("solve a new check state")
            solver = checkpointSolver.CheckpointSolver(self.proj, check_state, guide_state, heap, debugger)
            solutions = solver.solve()
            if len(solutions) == 0:
                check_state = last_check_state
                heap = self.heap
                guide_state = self.goal_state
                trial += 1
            else:
                check_state = check_state.checkpoint.checkstate
                guide_state = solutions[0][0]
                heap= solutions[0][1]
        if check_state is None:
            return (guide_state, heap)

    def __state_contains_var(self, state, var):
        if var == None:
            return False
        for v in state.solver.all_variables:
            if v is var:
                return True
        return False

    def __analyse_returns(self):
        for symbol in self.goal_state.checkpoint.ret_vars:
            for c in self.goal_state.solver.constraints:
                found = False
                for l in c.leaf_asts():
                    if l is var:
                        self.constrained_return_value.append(symbol)
                        found = True
                        break;
                if found:
                    break;

            obj_idx = self.goal_state.record.check_inside_obj_index(symbol)
            if obj_idx is not None: # returns a pointer
                c = {
                    'symbol': symbol,
                    'type': 'pointer',
                    'point_to': obj_idx,
                }
                self.objects[obj_idx] = symbol
            else:
                # a value or unused
                c = { 'symbol': symbol, 'type': 'value' }
            self.return_vars.append(c)
